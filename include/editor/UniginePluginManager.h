/* Copyright (C) 2005-2022, UNIGINE. All rights reserved.
 *
 * This file is a part of the UNIGINE 2 SDK.
 *
 * Your use and / or redistribution of this software in source and / or
 * binary form, with or without modification, is subject to: (i) your
 * ongoing acceptance of and compliance with the terms and conditions of
 * the UNIGINE License Agreement; and (ii) your inclusion of this notice
 * in any version of this software that you use or redistribute.
 * A copy of the UNIGINE License Agreement is available by contacting
 * UNIGINE. at http://unigine.com/
 */

#pragma once


#include <editor/UnigineEditorGlobal.h>

#include <UnigineString.h>
#include <UnigineVector.h>

#include <QObject>


////////////////////////////////////////////////////////////////////////////////
// Forward decl.
////////////////////////////////////////////////////////////////////////////////
namespace UnigineEditor
{
class Application;
class PluginInfo;
}


namespace UnigineEditor
{
/// <summary>The `UnigineEditor::PluginManager` is the main controller class of the Plugin System, it is responsible for:
/// <list type="bullet">
/// <item>Locating dynamic libraries in folders specified by the user.</item>
/// <item>Plugins initialization their lifecycle management and destruction via the instances of PluginInfo class.</item>
/// <item>Building plugins loading queue, as the order in which the plugins are loaded is important.
/// If a plugin has a required dependency it expects for certain symbols to be loaded.</item>
/// <item>Providing the user with information on plugins. Currently used to build target UI in the Editor.</item>
/// </list>
/// </summary>
class UNIGINE_EDITOR_API PluginManager final : public QObject
{
	Q_OBJECT
public:
	/// <summary> Returns the instance of the PluginManager class. This method is used to subscribe to signals.</summary>
	/// <returns> PluginManager class instance.</returns>
	/// <example> <b>Example:</b>
	/// <code>
	/// connect(UnigineEditor::PluginManager::instance(), &UnigineEditor::PluginManager::initializationCompleted
	///   , this, &SomeClass::plugin_manager_initialized);
	/// </code>
	/// </example>
	static PluginManager *instance();

	/// <summary> Loads specifications for all plugins found in the specified directories
	/// and tries to read all plugins metadata and resolve all dependencies 
	/// (change the state of all PluginInfo instances from INVALID to RESOLVED).
	/// This method builds the list of all available plugins.</summary>
	/// <param name="search_paths"> List of directories to look for plugin binary files in.</param>
	static void loadPluginSpecs(const Unigine::Vector<Unigine::String> &search_paths);
	/// <summary> Loads and initializes all available plugins from the list generated by calling the loadPluginSpecs() method
	/// (PluginInfo states LOADED and RUNNING).</summary>
	static void loadPlugins();
	/// <summary> Destroys all currently loaded plugins and unloads dynamic libraries from memory
	/// (PluginInfo states STOPPED and UNLOADED).</summary>
	static void unloadPlugins();

	/// <summary> Loads and initializes the plugin.
	/// (PluginInfo states LOADED and RUNNING).</summary>
	static bool loadPlugin(PluginInfo *plugin_info);

	/// <summary> Destroys the loaded plugin and unloads its dynamic library from memory.
	/// (PluginInfo states STOPPED and UNLOADED). Calling this method also clears both Editor and 
	/// selection undo stacks (the same happens on clicking Unload in the Editor's Plugins window).</summary>
	static bool unloadPlugin(PluginInfo *plugin_info);

	/// <summary> Returns information on all plugins currently available
	/// as a vector of PluginInfo items containing all necessary information on each plugin.</summary>
	static Unigine::Vector<PluginInfo *> plugins();

	/// <summary> Returns true if at least one error has occurred when loading any of the plugins available.
	/// If the result is positive, you can use the allErrors() method to get detailed information on all errors.
	/// </summary>
	static bool hasError();
	/// <summary> Returns detailed information on all plugin errors accurred as a vector of strings (one string per error).</summary>
	static Unigine::Vector<Unigine::String> allErrors();

	/// <summary> Returns a value indicating if the PluginManager is initialized successfully 
	/// (i.e. all plugins from the loading queue are loaded and initialized).
	/// </summary>
	/// <returns> <b>true</b> if the PluginManager was successfully initialized; otherwise, <b>false</b>.</returns>
	static bool isInitialized();

signals:
	/// <summary> This signal is emitted when the PluginManager initialization is completed 
	/// (i.e. all plugins from the loading queue are loaded and initialized).
	/// </summary>
	void initializationCompleted();

	/// <summary> This signal is emitted right before loading a plugin.</summary>
	void aboutToBeLoadedPlugin(PluginInfo *plugin_info);
	/// <summary> This signal is emitted when a plugin is successfully loaded.</summary>
	void loadedPlugin(PluginInfo *plugin_info);
	/// <summary> This signal is emitted right before unloading a plugin.</summary>
	void aboutToBeUnloadedPlugin(PluginInfo *plugin_info);
	/// <summary> This signal is emitted when a plugin is unloaded.</summary>
	void unloadedPlugin(PluginInfo *plugin_info);

private:
	explicit PluginManager(QObject *parent = nullptr);
	~PluginManager() override;

	friend class ::UnigineEditor::Application; // initialization.
};

} // namespace UnigineEditor
