<?xml version='1.0'?>
<doc>
	<assembly>
		<name>Unigine</name>
	</assembly>
	<members>
		<member name="M:Unigine.ShapeContact.#ctor">
			<summary>
			ShapeContact class constructor.
			</summary>  
		</member>
		<member name="M:Unigine.ShapeContact.setID(int)">
			<summary>
			Sets a new contact ID.
			</summary> 
			<param name="id"> Contact ID. </param> 
		</member>
		<member name="M:Unigine.ShapeContact.getID">
			<summary>
			Returns the contact ID.
			</summary>  
			<returns>Contact ID.</returns>
		</member>
		<member name="M:Unigine.ShapeContact.setSurface(int)">
			<summary>
			Sets a new contact surface number.
			</summary> 
			<param name="surface"> Contact surface number. </param> 
		</member>
		<member name="M:Unigine.ShapeContact.getSurface">
			<summary>
			Returns the contact surface number.
			</summary>  
			<returns>Contact surface number.</returns>
		</member>
		<member name="M:Unigine.ShapeContact.setTime(float)">
			<summary>
			Sets the time when the contact occurs. In case of CCD (for spheres or capsules), it's the time starting from the current physics simulation tick to the moment when the calculated contact is bound to happen. In case of non-continuous collision detection, it is always 0.
			</summary> 
			<param name="time"> Contact time, in milliseconds. </param> 
		</member>
		<member name="M:Unigine.ShapeContact.getTime">
			<summary>
			Returns the time when the contact occurs. In case of CCD (for spheres or capsules), it returns the time starting from the current physics simulation tick to the moment when the calculated contact is bound to happen. In case of non-continuous collision detection, 0 is always returned.
			</summary>  
			<returns>Contact time, in milliseconds.</returns>
		</member>
		<member name="M:Unigine.ShapeContact.setDepth(float)">
			<summary>
			Sets a new penetration depth of the contact. This distance is measured along the contact normal.
			</summary> 
			<param name="depth"> Contact depth, in units. </param> 
		</member>
		<member name="M:Unigine.ShapeContact.getDepth">
			<summary>
			Returns the penetration depth of the contact. This distance is measured along the contact normal.
			</summary>  
			<returns>Contact depth, in units.</returns>
		</member>
		<member name="M:Unigine.ShapeContact.setPoint(Unigine.Math.Vec3)">
			<summary>
			Sets new coordinates of the contact point.
			</summary> 
			<param name="point"> Coordinates of the contact point, in world coordinate system. </param> 
		</member>
		<member name="M:Unigine.ShapeContact.getPoint">
			<summary>
			Returns the coordinates of the contact point.
			</summary>  
			<returns>Coordinates of the contact point, in world coordinate system.</returns>
		</member>
		<member name="M:Unigine.ShapeContact.setNormal(Unigine.Math.vec3)">
			<summary>
			Sets new normal coordinates at the contact point.
			</summary> 
			<param name="normal"> Normal coordinates at the contact point. </param> 
		</member>
		<member name="M:Unigine.ShapeContact.getNormal">
			<summary>
			Returns the normal coordinates at the contact point.
			</summary>  
			<returns>Normal coordinates at the contact point.</returns>
		</member>
		<member name="M:Unigine.ShapeContact.setShape0(Unigine.Ptr{Unigine.Shape})">
			<summary>
			Sets the first shape participating in the contact.
			</summary> 
			<param name="shape0"> First shape participating in the contact. </param> 
		</member>
		<member name="M:Unigine.ShapeContact.getShape0">
			<summary>
			Returns the first shape participating in the contact.
			</summary>  
			<returns>First shape participating in the contact.</returns>
		</member>
		<member name="M:Unigine.ShapeContact.setShape1(Unigine.Ptr{Unigine.Shape})">
			<summary>
			Sets the second shape participating in the contact.
			</summary> 
			<param name="shape1"> Second shape participating in the contact. </param> 
		</member>
		<member name="M:Unigine.ShapeContact.getShape1">
			<summary>
			Returns the second shape participating in the contact.
			</summary>  
			<returns>Second shape participating in the contact.</returns>
		</member>
		<member name="M:Unigine.ShapeContact.setObject(Unigine.Ptr{Unigine.Object})">
			<summary>
			Sets the object participating in the contact.
			</summary> 
			<param name="val"> Contact object. </param> 
		</member>
		<member name="M:Unigine.ShapeContact.getObject">
			<summary>
			Returns the object participating in the contact.
			</summary>  
			<returns>Contact object.</returns>
		</member>
		<member name="M:Unigine.Physics.setAngularDamping(float)">
			<summary>
			Updates the current angular damping value.
			</summary> 
			<param name="damping"> New angular damping. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.Physics.getAngularDamping">
			<summary>
			Returns the current angular damping value.
			</summary>  
			<returns>Angular damping.</returns>
		</member>
		<member name="M:Unigine.Physics.getBody(int)">
			<summary>
			Returns a body with a given ID.
			</summary> 
			<param name="id"> Body ID. </param> 
			<returns>Body with a given ID or NULL (0), if there is no body with a given ID.</returns>
		</member>
		<member name="M:Unigine.Physics.isBody(int)">
			<summary>
			Checks if a body with a given ID exists.
			</summary> 
			<param name="id"> Body ID. </param> 
			<returns>1 if a body with a given ID exists; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Physics.setBudget(float)">
			<summary>
			Sets the physics simulation budget. Physics isn't simulated when time is out of the budget.
			</summary> 
			<param name="budget"> The budget value in seconds. </param> 
		</member>
		<member name="M:Unigine.Physics.getBudget">
			<summary>
			Returns the physics simulation budget. Physics isn't simulated when time is out of the budget.
			</summary>  
			<returns>The budget value in seconds. The default value is 1/20.</returns>
		</member>
		<member name="M:Unigine.Physics.setData(char)">
			<summary>
			Sets user data associated with the world. In the *.world file, the data is set in the data tag.
			</summary> 
			<param name="data"> New user data. </param> 
		</member>
		<member name="M:Unigine.Physics.getData">
			<summary>
			Returns user string data associated with the world. This string is written directly into the data tag of the *.world file.
			</summary>  
			<returns>User string data.</returns>
		</member>
		<member name="M:Unigine.Physics.setDistance(float)">
			<summary>
			Updates a distance after which the physics will not be simulated.
			</summary> 
			<param name="distance"> Distance in units. </param> 
		</member>
		<member name="M:Unigine.Physics.getDistance">
			<summary>
			Returns a distance after which the physics will not be simulated.
			</summary>  
			<returns>Distance in units.</returns>
		</member>
		<member name="M:Unigine.Physics.setEnabled(int)">
			<summary>
			Enables or disables physics simulation.
			</summary> 
			<param name="enable"> 1 to enable physics, 0 to disable it. </param> 
		</member>
		<member name="M:Unigine.Physics.isEnabled">
			<summary>
			Returns a value indicating if physics simulation is enabled. The default is 1.
			</summary>  
			<returns>1 if physics is enabled; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Physics.setSyncEngineUpdateWithPhysics(bool)">
			<summary>
			Sets a flag to synchronize the Engine FPS to physics one. Such FPS limitation allows to calculate physics each rendered frame (rather then interpolate it when this flag is unset). In this mode, there are no twitching of physical objects if they have non-linear velocities. If the Engine FPS is lower than the physics one, this flag has no effect.
			</summary> 
			<param name="fixed"> true to synchronize the Engine FPS to physics one; false to interpolate physics if the Engine FPS is higher. </param> 
		</member>
		<member name="M:Unigine.Physics.isSyncEngineUpdateWithPhysics">
			<summary>
			Returns a flag indicating if the Engine FPS is synchronized to physics one. Such FPS limitation allows to calculate physics each rendered frame (rather then interpolate it when this flag is unset). In this mode, there are no twitching of physical objects if they have non-linear velocities. If the Engine FPS is lower than the physics one, this flag has no effect.
			</summary>  
			<returns>true if the Engine FPS is synchronized to physics one; false if the physics is interpolated if the Engine FPS is higher.</returns>
		</member>
		<member name="M:Unigine.Physics.getFrame">
			<summary>
			Returns the current frame of physics update.
			</summary>  
			<returns>Frame number.</returns>
		</member>
		<member name="M:Unigine.Physics.setFrozenAngularVelocity(float)">
			<summary>
			Updates the angular velocity threshold for freezing object simulation. If the object angular velocity remains lower than this threshold during the number of Frozen frames (together with linear one), it stops to be updated.
			</summary> 
			<param name="velocity"> New "freeze" angular velocity. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.Physics.getFrozenAngularVelocity">
			<summary>
			Returns the current angular velocity threshold for freezing object simulation. An object stops to be updated if its angular velocity remains lower than this threshold during the number of Frozen frames (together with linear one).
			</summary>  
			<returns>"Freeze" angular velocity.</returns>
		</member>
		<member name="M:Unigine.Physics.setFrozenLinearVelocity(float)">
			<summary>
			Updates the linear velocity threshold for freezing object simulation. If the object linear velocity remains lower than this threshold during the number of Frozen frames (together with angular one), it stops to be updated.
			</summary> 
			<param name="velocity"> New "freeze" linear velocity. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.Physics.getFrozenLinearVelocity">
			<summary>
			Returns the current linear velocity threshold for freezing object simulation. An object stops to be updated if its linear velocity remains lower than this threshold during the number of Frozen frames (together with angular one).
			</summary>  
			<returns>"Freeze" linear velocity.</returns>
		</member>
		<member name="M:Unigine.Physics.setGravity(Unigine.Math.vec3)">
			<summary>
			Updates the current gravity value.
			</summary> 
			<param name="gravity"> New gravity. </param> 
		</member>
		<member name="M:Unigine.Physics.getGravity">
			<summary>
			Returns the current gravity value.
			</summary>  
			<returns>Gravity.</returns>
		</member>
		<member name="M:Unigine.Physics.setIFps(float)">
			<summary>
			Updates a frame duration. In fact, this function updates the FPS count used to calculate physics.
			</summary> 
			<param name="ifps"> Frame duration (1/FPS). </param> 
		</member>
		<member name="M:Unigine.Physics.getIFps">
			<summary>
			Returns a physics frame duration.
			</summary>  
			<returns>Frame duration (1 / FPS).</returns>
		</member>
		<member name="M:Unigine.Physics.getIntegrateTime">
			<summary>
			Returns the duration of the integrate phase, in which physics simulation results are applied to bodies.
			</summary>  
			<returns>An integrate phase duration value, milliseconds.</returns>
		</member>
		<member name="M:Unigine.Physics.getIntersection(Unigine.Math.Vec3,Unigine.Math.Vec3,int,Unigine.Vector{Unigine.Ptr{Unigine.Node},int,Unigine.VectorAllocator},Unigine.Ptr{PhysicsIntersection})">
			<summary>
								Performs tracing from the p0 point to the p1 point to find a collision object located on that line. If an object is assigned a body, intersection occurs with its shape. If an object has no body, this function detects intersection with surfaces (polygons) of objects with intersection flag set. Intersection is found only for objects with a matching mask if their ID is not found in the exclude list. Intersection is Intersection does not work for disabled objects. 					This function uses world space coordinates.
			</summary> 
			<param name="p0"> Line start point coordinates. </param>
			<param name="p1"> Line end point coordinates. </param>
			<param name="mask"> Physics intersection mask. If 0 is passed, the function will return NULL. </param>
			<param name="exclude"> Array of nodes to be excluded. </param>
			<param name="intersection"> PhysicsIntersection class instance containing intersection data. </param> 
			<returns>The first intersected object, if found; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Physics.getIntersection(Unigine.Math.Vec3,Unigine.Math.Vec3,int,Unigine.Ptr{PhysicsIntersection})">
			<summary>
								Performs tracing from the p0 point to the p1 point to find a collision object located on that line. If an object is assigned a body, intersection occurs with its shape. If an object has no body, this function detects intersection with surfaces (polygons) of objects with intersection flag set. Physics intersection shall only be detected for objects with a matching mask. Intersection does not work for disabled objects. 					This function uses world space coordinates.					Usage Example					The following example shows how you can get the intersection information by using the PhysicsIntersection class. In this example the line is an invisible traced line from the point of the camera (vec3 p0) to the point of the mouse pointer (vec3 p1). The executing sequence is the following:											Define and initialize two points (p0 and p1) by using the Player::getDirectionFromScreen() function.						Create an instance of the PhysicsIntersection class to get the intersection information.						Check, if there is an intersection with an object. The getIntersection() function returns an intersected object when the object intersects with the traced line.						When the object intersects with the traced line, all the surfaces of the intersected object change their material parameters. If the object has a shape, its information will be shown in the console. The PhysicsIntersection class instance gets the coordinates of the intersection point and the Shape class object. You can get all these fields by using getShape(), getPoint() functions.
			</summary> 
			<param name="p0"> Line start point coordinates. </param>
			<param name="p1"> Line end point coordinates. </param>
			<param name="mask"> Physics intersection mask. If 0 is passed, the function will return NULL. </param>
			<param name="intersection"> PhysicsIntersection class instance containing intersection data. </param> 
			<returns>The first intersected object, if found; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Physics.getIntersection(Unigine.Math.Vec3,Unigine.Math.Vec3,int,Unigine.Ptr{PhysicsIntersectionNormal})">
			<summary>
								Performs tracing from the p0 point to the p1 point to find a collision object located on that line. If an object is assigned a body, intersection occurs with its shape. If an object has no body, this function detects intersection with surfaces (polygons) of objects with intersection flag set. Physics intersection shall only be detected for objects with a matching mask. Intersection does not work for disabled objects. 					This function uses world space coordinates.
			</summary> 
			<param name="p0"> Line start point coordinates. </param>
			<param name="p1"> Line end point coordinates. </param>
			<param name="mask"> Physics intersection mask. If 0 is passed, the function will return NULL. </param>
			<param name="intersection"> PhysicsIntersectionNormal class instance containing intersection data. </param> 
			<returns>The first intersected object, if found; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Physics.getIntersection(Unigine.Math.Vec3,Unigine.Math.Vec3,int,Unigine.Vector{Unigine.Ptr{Unigine.Node},int,Unigine.VectorAllocator},Unigine.Ptr{PhysicsIntersectionNormal})">
			<summary>
								Performs tracing from the p0 point to the p1 point to find a collision object located on that line. If an object is assigned a body, intersection occurs with its shape. If an object has no body, this function detects intersection with surfaces (polygons) of objects with intersection flag set. Intersection is found only for objects with a matching mask if their ID is not found in the exclude list. Intersection is Intersection does not work for disabled objects. 					This function uses world space coordinates.
			</summary> 
			<param name="p0"> Line start point coordinates. </param>
			<param name="p1"> Line end point coordinates. </param>
			<param name="mask"> Physics intersection mask. If 0 is passed, the function will return NULL. </param>
			<param name="exclude"> Array of nodes to be excluded. </param>
			<param name="intersection"> PhysicsIntersectionNormal class instance containing intersection data. </param> 
			<returns>The first intersected object, if found; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Physics.getJoint(int)">
			<summary>
			Returns a joint with a given ID.
			</summary> 
			<param name="id"> Joint ID. </param> 
			<returns>Joint with a given ID or NULL (0), if there is no joint with a given ID.</returns>
		</member>
		<member name="M:Unigine.Physics.isJoint(int)">
			<summary>
			Checks if a joint with a given ID exists.
			</summary> 
			<param name="id"> Joint ID. </param> 
			<returns>1 if a joint with a given ID exists; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Physics.setLinearDamping(float)">
			<summary>
			Updates the current linear damping value.
			</summary> 
			<param name="damping"> New linear damping. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.Physics.getLinearDamping">
			<summary>
			Returns the current linear damping value.
			</summary>  
			<returns>Linear damping.</returns>
		</member>
		<member name="M:Unigine.Physics.setMaxAngularVelocity(float)">
			<summary>
			Updates the maximum possible angular velocity.
			</summary> 
			<param name="velocity"> New maximum velocity value. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.Physics.getMaxAngularVelocity">
			<summary>
			Returns the current maximum possible angular velocity.
			</summary>  
			<returns>Maximum possible angular velocity.</returns>
		</member>
		<member name="M:Unigine.Physics.setMaxLinearVelocity(float)">
			<summary>
			Updates the maximum possible linear velocity.
			</summary> 
			<param name="velocity"> New maximum velocity value. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.Physics.getMaxLinearVelocity">
			<summary>
			Returns the current maximum possible linear velocity.
			</summary>  
			<returns>Maximum possible linear velocity.</returns>
		</member>
		<member name="M:Unigine.Physics.getCollisionTime">
			<summary>
			Returns the duration of the collision detection phase, during which collisions between objects are found.
			</summary>  
			<returns>Collision detection phase duration, in milliseconds.</returns>
		</member>
		<member name="M:Unigine.Physics.getNumBodies">
			<summary>
			Returns the number of bodies present within the physics radius.
			</summary>  
			<returns>The number of bodies.</returns>
		</member>
		<member name="M:Unigine.Physics.getNumContacts">
			<summary>
			Returns the number of contacts within the physics radius; it includes contacts between the bodies (their shapes) and body-mesh contacts.
			</summary>  
			<returns>The number of contacts.</returns>
		</member>
		<member name="M:Unigine.Physics.setNumFrozenFrames(int)">
			<summary>
			Updates the number of frames, during which an object should keep certain angular and linear velocities to become frozen.
			</summary> 
			<param name="frames"> Number of frames. If a non-positive value is provided, 1 will be used instead. </param> 
		</member>
		<member name="M:Unigine.Physics.getNumFrozenFrames">
			<summary>
			Returns the current number of frames, during which an object should keep certain angular and linear velocities to become frozen.
			</summary>  
			<returns>Number of frames.</returns>
		</member>
		<member name="M:Unigine.Physics.getNumIslands">
			<summary>
			Returns the number of physical islands within the physics radius that could be calculated separately. The lower this number, the less efficient multi-threading is, if enabled.
			</summary>  
			<returns>The number of physical islands.</returns>
		</member>
		<member name="M:Unigine.Physics.setNumIterations(int)">
			<summary>
			Updates the number of iterations used to solve contacts and constraints. Note that if this value is too low, the precision of calculations will suffer.
			</summary> 
			<param name="iterations"> New number of iterations. If a non-positive value is provided, 1 will be used instead. </param> 
		</member>
		<member name="M:Unigine.Physics.getNumIterations">
			<summary>
			Returns the current number of iterations used to solve contacts and constraints.
			</summary>  
			<returns>Current number of iterations.</returns>
		</member>
		<member name="M:Unigine.Physics.getNumJoints">
			<summary>
			Returns the number of joints within the physics radius.
			</summary>  
			<returns>The number of joints.</returns>
		</member>
		<member name="M:Unigine.Physics.setPenetrationFactor(float)">
			<summary>
			Updates the current penalty force factor.
			</summary> 
			<param name="factor"> New penetration factor. 0 means no penalty force in contacts. The provided value is saturated in the range [0; 1]. </param> 
		</member>
		<member name="M:Unigine.Physics.getPenetrationFactor">
			<summary>
			Returns a penalty force factor. 0 means no penalty force in contacts. The maximum value is 1.
			</summary>  
			<returns>Current penetration factor.</returns>
		</member>
		<member name="M:Unigine.Physics.setPenetrationTolerance(float)">
			<summary>
			Updates the current penetration tolerance.
			</summary> 
			<param name="tolerance"> New penetration tolerance. If a negative value is provided, 0 will be used instead, however, this value should be greater than 0 for stable simulation. </param> 
		</member>
		<member name="M:Unigine.Physics.getPenetrationTolerance">
			<summary>
			Returns a value indicating how deeply one object can penetrate another.
			</summary>  
			<returns>Current penetration tolerance.</returns>
		</member>
		<member name="M:Unigine.Physics.getResponseTime">
			<summary>
			Returns the duration value of the response phase, in which collision response is calculated and joints are solved.
			</summary>  
			<returns>A response phase duration value, milliseconds.</returns>
		</member>
		<member name="M:Unigine.Physics.setScale(float)">
			<summary>
			Updates a value that is used to scale a frame duration. The provided value is saturated in the range [0;16].
			</summary> 
			<param name="scale"> Scaling factor. </param> 
		</member>
		<member name="M:Unigine.Physics.getScale">
			<summary>
			Returns a value used to scale a frame duration.
			</summary>  
			<returns>Value to scale the frame duration.</returns>
		</member>
		<member name="M:Unigine.Physics.getShape(int)">
			<summary>
			Returns a shape with a given ID.
			</summary> 
			<param name="id"> Shape ID. </param> 
			<returns>Shape with a given ID or NULL (0), if there is no shape with a given ID.</returns>
		</member>
		<member name="M:Unigine.Physics.isShape(int)">
			<summary>
			Checks if a shape with a given ID exists.
			</summary> 
			<param name="id"> Shape ID. </param> 
			<returns>1 if a shape with a given ID exists; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Physics.getSimulationTime">
			<summary>
			Returns the duration of all of the simulation phases added together.
			</summary>  
			<returns>A simulation phases duration value, milliseconds.</returns>
		</member>
		<member name="M:Unigine.Physics.setDeterminism(bool)">
			<summary>
			Sets a value indicating if objects are updated in a definite order or not. Deterministic mode ensures that all contacts are solved in the predefined order and visualization of physics in the world is repetitive (on one computer). When this mode is enabled the Engine performs additional sorting of bodies, shapes and joints inside islands after building them. Deterministic mode is unavailable in case there are missed frames - it is simply impossible. Moreover, there may be differences between visualization of physics on different hardware (e.g., AMD and Intel).					Determinism is guaranteed if there are no missed frames, the same Engine version is used, and the CPUs perform SSE operations similarly.Please note that deterministic mode does not come for free, it may eat up 10-20% of the frame rate, and it also depends on the scene a lot.
			</summary> 
			<param name="stable"> true to indicate that the objects are updated in a definite order; false to indicate that an objects update order may change. The default is false (the update order may change). </param> 
		</member>
		<member name="M:Unigine.Physics.isDeterminism">
			<summary>
			Returns a value indicating if objects are updated in a definite order or not.Deterministic mode ensures that all contacts are solved in the predefined order and visualization of physics in the world is repetitive (on one computer). When this mode is enabled the Engine performs additional sorting of bodies, shapes and joints inside islands after building them. Deterministic mode is unavailable in case there are missed frames - it is simply impossible. Moreover, there may be differences between visualization of physics on different hardware (e.g., AMD and Intel).					Determinism is guaranteed if there are no missed frames, the same Engine version is used, and the CPUs perform SSE operations similarly.Please note that deterministic mode does not come for free, it may eat up 10-20% of the frame rate, and it also depends on the scene a lot.
			</summary>  
			<returns>true if the objects are updated in a definite order; otherwise false. The default is false (the update order may change).</returns>
		</member>
		<member name="M:Unigine.Physics.setCurrentSubframeTime(float)">
			<summary>
			Forces simulation of physics for a given time. It means, until the set time elapses, physics will be calculated each physics tick (frame) that occurs depending on physics frame rate. It allows you to control the starting point for physics simulation.					ifps is the time between frames of the renderer.
			</summary> 
			<param name="time"> Time to continue updating physics in seconds. </param> 
		</member>
		<member name="M:Unigine.Physics.getCurrentSubframeTime">
			<summary>
			Returns the current time that can be used when shifting between physics update frames.
			</summary>  
			<returns>Time in seconds.</returns>
		</member>
		<member name="M:Unigine.Physics.getTotalTime">
			<summary>
			Returns the total time that both rendering and calculating of the frame took (the duration of the main loop in the application execution sequence).
			</summary>  
			<returns>The total time value, milliseconds.</returns>
		</member>
		<member name="M:Unigine.Physics.addUpdateNode(Unigine.Ptr{Unigine.Node})">
			<summary>
			Adds the node for which physical state should be updated. If a node is not added with this function, it won't be updated when out of physics simulation distance.
			</summary> 
			<param name="node"> Node to be updated. </param> 
		</member>
		<member name="M:Unigine.Physics.addUpdateNodes(Unigine.Vector{Unigine.Ptr{Unigine.Node},int,Unigine.VectorAllocator})">
			<summary>
			Adds the nodes for which physical state should be updated. If nodes are not added with this function, they won't be updated when out of physics simulation distance.
			</summary> 
			<param name="nodes"> Nodes to be updated. </param> 
		</member>
		<member name="M:Unigine.Physics.loadSettings(char,bool) const">
			<summary>
			Loads the physics settings from a given file.
			</summary> 
			<param name="name"> Path to an XML file with desired settings. </param>
			<param name="clear"> Clear flag. Set true to clear settings before loading (new settings shall be applied right after loading them), or false not to clear. </param> 
			<returns>Returns 1 if the settings are loaded successfully; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Physics.loadWorld(Unigine.Ptr{Unigine.Xml})">
			<summary>
			Loads physics settings from the Xml.
			</summary> 
			<param name="xml"> Xml smart pointer. </param> 
			<returns>Returns 1 if settings are loaded successfully; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Physics.saveScene">
			<summary>
			Saves the current physics scene (physical properties of all objects) into the buffer.
			</summary>  
			<returns>Scene buffer ID.</returns>
		</member>
		<member name="M:Unigine.Physics.restoreScene(int)">
			<summary>
			Restores the previously saved physics scene from the buffer.
			</summary> 
			<param name="id"> Buffer ID. </param> 
			<returns>Returns 1 if the scene is restored successfully; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Physics.removeScene(int)">
			<summary>
			Removes the previously saved physics scene.
			</summary> 
			<param name="id"> Buffer ID. </param> 
			<returns>Returns 1 if the scene is removed successfully; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Physics.saveState(Unigine.Ptr{Unigine.Stream})">
			<summary>
			Saves physics settings into the stream.					Example using saveState() and restoreState() methods:
			</summary> 
			<param name="stream"> Stream smart pointer. </param> 
			<returns>true if settings are saved successfully; otherwise, false.</returns>
		</member>
		<member name="M:Unigine.Physics.restoreState(Unigine.Ptr{Unigine.Stream})">
			<summary>
			Restores physics settings from the stream.					Example using saveState() and restoreState() methods:
			</summary> 
			<param name="stream"> Stream smart pointer. </param> 
			<returns>true if settings are restored successfully; otherwise, false.</returns>
		</member>
		<member name="M:Unigine.Physics.saveSettings(char,int)">
			<summary>
			Saves the current physics settings to a given file.
			</summary> 
			<param name="name"> Path to an xml file to which the settings will be saved. </param>
			<param name="force"> Forced saving of physics settings. </param> 
			<returns>true if the settings are saved successfully; otherwise, false.</returns>
		</member>
		<member name="M:Unigine.Physics.saveWorld(Unigine.Ptr{Unigine.Xml},int)">
			<summary>
			Saves physics settings to the given Xml node.
			</summary> 
			<param name="xml"> Xml smart pointer. </param>
			<param name="force"> Forced saving of physics settings. </param> 
			<returns>true if settings are saved successfully; otherwise, false.</returns>
		</member>
		<member name="M:Unigine.Physics.setStableFPS(bool)">
			<summary>
			Returns a value indicating if frame time stabilization is enabled. In case the current Engine framerate is much higher than the fixed Physics framerate (e.g. 120 FPS vs 60 FPS), the physics won't be updated each rendering frame (e.g. it may update during every second frame). The resulting frame time will become unstable, shorter-longer-shorter-longer (render -&gt; render+physics -&gt; render -&gt; render+physics...). This option ensures stable frame time for smoother user experience removing unwanted "hiccups" (however, the average framerate is decreased).By default, this option is enabled. But you can disable it to increase average framerate in case the application is used for machine learning or for grabbing frame sequences (video grabber), when smoothness is not important.
			</summary> 
			<param name="stablefps"> true to enable frame time stabilization; false - to disable it. </param> 
		</member>
		<member name="M:Unigine.Physics.isStableFPS const">
			<summary>
			Returns a value indicating if frame time stabilization is enabled. In case the current Engine framerate is much higher than the fixed Physics framerate (e.g. 120 FPS vs 60 FPS), the physics won't be updated each rendering frame (e.g. it may update during every second frame). The resulting frame time will become unstable, shorter-longer-shorter-longer (render -&gt; render+physics -&gt; render -&gt; render+physics...). This option ensures stable frame time for smoother user experience removing unwanted "hiccups" (however, the average framerate is decreased).By default, this option is enabled. But you can disable it to increase average framerate in case the application is used for machine learning or for grabbing frame sequences (video grabber), when smoothness is not important.
			</summary>  
			<returns>true if frame time stabilization is enabled; otherwise, false.</returns>
		</member>
		<member name="M:Unigine.Physics.setUpdateMode(Physics::UPDATE_MODE)">
			<summary>
			Sets the update mode to be used for physics. Physics can be updated either asynchronously (in parallel with rendering) or in the Main thread before rendering. The async mode is the fastest one and is used by default, however, it has a one-frame lag (calculation results are applied in the next frame) and some nuances regarding user code execution in some cases.
			</summary> 
			<param name="mode"> New physics update mode to be set. </param> 
		</member>
		<member name="M:Unigine.Physics.getUpdateMode const">
			<summary>
			Returns the current physics update mode. Physics can be updated either asynchronously (in parallel with rendering) or in the Main thread before rendering. The async mode is the fastest one and is used by default, however, it has a one-frame lag (calculation results are applied in the next frame) and some nuances regarding user code execution in some cases.
			</summary>  
			<returns>Current physics update mode.</returns>
		</member>
		<member name="M:Unigine.Physics.setMissedFrameLifetime(float)">
			<summary>
			Sets the lifetime for missed frames. This value defines how long missed frames are to be kept in the catch-up buffer. In case the current Engine framerate is lower than the fixed Physics framerate, some of the physics frames get skipped and the simulation starts looking like in a slo-mo effect (e.g., if the target physics framerate is 60 FPS, when the Engine updates at 30 FPS, the simulation will look 2 times slower). The Physics module will try to catch up everything missed later, when possible (e.g. when the Engine framerate grows higher, while waiting for GPU to complete rendering). The missed frames are kept in a buffer for some time (lifetime), as it expires the frame is removed from the buffer and becomes lost forever.
			</summary> 
			<param name="lifetime"> Lifetime for missing frame, in milliseconds. Setting too high values may result in significant memory consumption in case of low hardware capabilities (no catching-up performed with a growing number of missed frames). </param> 
		</member>
		<member name="M:Unigine.Physics.getMissedFrameLifetime const">
			<summary>
			Sets the lifetime for missed frames. This value defines how long missed frames are to be kept in the catch-up buffer. In case the current Engine framerate is lower than the fixed Physics framerate, some of the physics frames get skipped and the simulation starts looking like in a slo-mo effect (e.g., if the target physics framerate is 60 FPS, when the Engine updates at 30 FPS, the simulation will look 2 times slower). The Physics module will try to catch up everything missed later, when possible (e.g. when the Engine framerate grows higher, while waiting for GPU to complete rendering). The missed frames are kept in a buffer for some time (lifetime), as it expires the frame is removed from the buffer and becomes lost forever.
			</summary>  
			<returns>Lifetime for missing frame, in milliseconds. Setting too high values may result in significant memory consumption in case of low hardware capabilities (no catching-up performed with a growing number of missed frames).</returns>
		</member>
		<member name="F:Unigine.Physics.UPDATE_MODE_ASYNC_RENDERING">
			<summary>
			Asynchronous update mode. Physics update is performed asynchronously to rendering. In case of several physics ticks per one rendering frame (when the Engine framerate is lower, or catching up is performed), only the first one is executed in parallel, then the physics module waits for the completion of the rendering process, returns to the Main thread and executes the rest of the physics ticks. There is a frame lag (results of physics calculations are applied in the next frame) and there is some ambiguity regarding the time, when user code (physicsUpdate and physics callbacks) is to be executed in case of several physics ticks per one rendering frame (some part is executed before rendering while the other just after it). This mode is the fastest one and is used by default.
		</summary>
		</member>
		<member name="F:Unigine.Physics.UPDATE_MODE_BEFORE_RENDERING">
			<summary>
			Update Before Rendering. Physics update (along with the spatial tree update and user callbacks) is executed in the Main thread just before rendering is performed (render). The number of physics ticks executed before the rendering frame here is defined by the physics and the Engine framerates. This mode is the most clear and straightforward (everything is executed safely in a strictly determined order) with no frame lag (results of physics calculations are applied in the current frame). But, on the other hand, this mode is the slowest as there are no asynchronous parallel calculations (everything's in the Main thread). Use this mode in case the time lag is unacceptabe for your application (you need all physics calculations to be applied in the current frame) and you want maximum simplicity and strictly determined order of execution for user code (physicsUpdate and physics callbacks).
		</summary>
		</member>
		<member name="M:Unigine.PhysicsIntersection.#ctor">
			<summary>
			The PhysicsIntersection constructor.
			</summary>  
		</member>
		<member name="M:Unigine.PhysicsIntersection.setPoint(Unigine.Math.Vec3)">
			<summary>
			Sets new coordinates of the intersection point.
			</summary> 
			<param name="point"> Coordinates of the intersection point. </param> 
		</member>
		<member name="M:Unigine.PhysicsIntersection.getPoint">
			<summary>
			Returns coordinates of the intersection point.
			</summary>  
			<returns>Coordinates of the intersection point.</returns>
		</member>
		<member name="M:Unigine.PhysicsIntersection.setShape(Unigine.Ptr{Unigine.Shape})">
			<summary>
			Sets the new intersection shape.
			</summary> 
			<param name="shape"> Intersection shape. </param> 
		</member>
		<member name="M:Unigine.PhysicsIntersection.getShape">
			<summary>
			Returns the intersection shape.
			</summary>  
			<returns>Intersection shape.</returns>
		</member>
		<member name="M:Unigine.PhysicsIntersection.setSurface(int)">
			<summary>
			Sets the new intersection surface number.
			</summary> 
			<param name="surface"> Intersection surface number. </param> 
		</member>
		<member name="M:Unigine.PhysicsIntersection.getSurface">
			<summary>
			Returns the intersected surface number.
			</summary>  
			<returns>Intersected surface number.</returns>
		</member>
		<member name="M:Unigine.PhysicsIntersection.getType">
			<summary>
			Returns the type of physics intersection. The type defines information stored by the object (if the data on the normal at the intersection point is included or not).
			</summary>  
			<returns>Physics intersection type, one of the TYPE values.</returns>
		</member>
		<member name="M:Unigine.PhysicsIntersection.getTypeName">
			<summary>
			Returns the name of the physics intersection type. The type defines information stored by the object (if the data on the normal at the intersection point is included or not).
			</summary>  
			<returns>Name of the physics intersection type. One of the following values:PhysicsIntersectionPhysicsIntersectionNormal</returns>
		</member>
		<member name="F:Unigine.PhysicsIntersection.PHYSICS_INTERSECTION">
			<summary>
			PhysicsIntersection object, which stores basic information on the intersection point (coordinates of the intersection, the shape of the object, the index of the surface).
		</summary>
		</member>
		<member name="F:Unigine.PhysicsIntersection.PHYSICS_INTERSECTION_NORMAL">
			<summary>
			PhysicsIntersectionNormal object, which stores the same information as the PhysicsIntersection object plus additional information on the normal at the intersection point.
		</summary>
		</member>
		<member name="M:Unigine.PhysicsIntersectionNormal.#ctor">
			<summary>
			The PhysicsIntersectionNormal constructor.
			</summary>  
		</member>
		<member name="M:Unigine.PhysicsIntersectionNormal.setNormal(Unigine.Math.vec3)">
			<summary>
			Sets the new normal of the intersection point.
			</summary> 
			<param name="normal"> Normal of the intersection point. </param> 
		</member>
		<member name="M:Unigine.PhysicsIntersectionNormal.getNormal">
			<summary>
			Returns the normal of the intersection point.
			</summary>  
			<returns>Normal of the intersection point.</returns>
		</member>
		<member name="M:Unigine.Body.createBody(int)">
			<summary>
			Creates a new body of the specified type.
			</summary> 
			<param name="type"> Body type. One of the BODY_* values. </param> 
			<returns>New created body smart pointer.</returns>
		</member>
		<member name="M:Unigine.Body.createBody(char)">
			<summary>
			Creates a new body of the specified type.
			</summary> 
			<param name="type_name"> Body type name. </param> 
			<returns>New created body smart pointer.</returns>
		</member>
		<member name="M:Unigine.Body.setID(int)">
			<summary>
			Sets the unique ID for the body.
			</summary> 
			<param name="id"> Unique ID. </param> 
		</member>
		<member name="M:Unigine.Body.getID const">
			<summary>
			Returns the unique ID of the body.
			</summary>  
			<returns>Unique ID.</returns>
		</member>
		<member name="M:Unigine.Body.getType const">
			<summary>
			Returns the type of the body.
			</summary>  
			<returns>One of the BODY_* pre-defined variables. </returns>
		</member>
		<member name="M:Unigine.Body.getTypeName const">
			<summary>
			Returns the name of the body type.
			</summary>  
			<returns>Type name.</returns>
		</member>
		<member name="M:Unigine.Body.getTypeName(int)">
			<summary>
			Returns the name of a body type with a given ID.
			</summary> 
			<param name="type"> Body type ID. One of the BODY_* values. </param> 
			<returns>Body type name.</returns>
		</member>
		<member name="M:Unigine.Body.setObject(Unigine.Ptr{Unigine.Object},bool)">
			<summary>
			Sets an object, which the body approximates.
			</summary> 
			<param name="object"> Object to approximate. </param>
			<param name="update"> Update flag: 1 to update the object after assigning the body (by default), 0 not to update right after body assignment. </param> 
		</member>
		<member name="M:Unigine.Body.setObject(Unigine.Ptr{Unigine.Object})">
			<summary>
			Sets an object, which the body approximates.
			</summary> 
			<param name="val"> Object to approximate. </param> 
		</member>
		<member name="M:Unigine.Body.getObject const">
			<summary>
			Returns the object, which is approximated with the body.
			</summary>  
			<returns>Approximated object.</returns>
		</member>
		<member name="M:Unigine.Body.setEnabled(bool)">
			<summary>
			Enables or disables physical interactions with the body.
			</summary> 
			<param name="enable"> 1 to enable physical interactions, 0 to disable them.  </param> 
		</member>
		<member name="M:Unigine.Body.isEnabled const">
			<summary>
			Returns a value indicating if physical interactions with the body are enabled.
			</summary>  
			<returns>1 if physical interactions with the body are enabled; otherwise, 0. </returns>
		</member>
		<member name="M:Unigine.Body.isEnabledSelf const">
			<summary>
			Returns a value indicating if the body is enabled.
			</summary>  
			<returns>1 if the body is enabled; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Body.setFrozen(bool)">
			<summary>
			Freezes or unfreezes the body. When a body is frozen, it is not simulated (though its contacts are still calculated), until a collision with a frozen body occurs or some force is applied.
			</summary> 
			<param name="frozen"> 1 to freeze the object, 0 to unfreeze it.  </param> 
		</member>
		<member name="M:Unigine.Body.isFrozen const">
			<summary>
			Returns a value indicating if the body is frozen. When a body is frozen, it is not simulated (though its contacts are still calculated), until a collision with a frozen body occurs or some force is applied.
			</summary>  
			<returns>1 if the body is frozen; otherwise, 0. </returns>
		</member>
		<member name="M:Unigine.Body.setImmovable(bool)">
			<summary>
			Sets a value indicating if the body is immovable (static).
			</summary> 
			<param name="immovable"> 1 if the body is immovable (static); otherwise, 0. </param> 
		</member>
		<member name="M:Unigine.Body.isImmovable const">
			<summary>
			Return a value indicating if the body is immovable (static).
			</summary>  
			<returns>1 if the body is immovable (static); otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Body.setGravity(bool)">
			<summary>
			Sets a value indicating if gravity is affecting the body.
			</summary> 
			<param name="gravity"> 1 if the body is affected by gravity; otherwise, 0. </param> 
		</member>
		<member name="M:Unigine.Body.isGravity const">
			<summary>
			Returns a value indicating if gravity is affecting the body.
			</summary>  
			<returns>1 if the body is affected by gravity; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Body.setName(char)">
			<summary>
			Sets the name of the body.
			</summary> 
			<param name="name"> Name of the body. </param> 
		</member>
		<member name="M:Unigine.Body.getName const">
			<summary>
			Returns the name of the body.
			</summary>  
			<returns>Name of the body.</returns>
		</member>
		<member name="M:Unigine.Body.setPhysicalMask(int)">
			<summary>
			Sets the bit mask for interactions with physicals. Two objects interact, if they both have matching masks.
			</summary> 
			<param name="mask"> Integer, each bit of which is a mask. </param> 
		</member>
		<member name="M:Unigine.Body.getPhysicalMask const">
			<summary>
			Returns the bit mask for interactions with physicals. Two objects interact, if they both have matching masks.
			</summary>  
			<returns>Integer, each bit of which is a mask.</returns>
		</member>
		<member name="M:Unigine.Body.setTransform(Unigine.Math.Mat4)">
			<summary>
			Sets a transformation matrix for the body (in world coordinates). This method resets body's linear and angular velocities to defaults, sets forces and torques to zeros, nullifies counted down frozen frames. It is called, for example, when the node is dragged to a new position in the editor.
			</summary> 
			<param name="transform"> Transformation matrix. This matrix describes position, orientation and scale of the body. </param> 
		</member>
		<member name="M:Unigine.Body.getTransform const">
			<summary>
			Returns the transformation matrix of the body (in world coordinates). This matrix describes position and orientation of the body.
			</summary>  
			<returns>Transformation matrix.</returns>
		</member>
		<member name="M:Unigine.Body.setPreserveTransform(Unigine.Math.Mat4)">
			<summary>
			Sets a transformation matrix for the body (in world coordinates). This method safely preserves body's linear and angular velocities. It changes only body coordinates - all other body parameters stay the same.
			</summary> 
			<param name="transform"> Transformation matrix. This matrix describes position, orientation and scale of the body. </param> 
		</member>
		<member name="M:Unigine.Body.setVelocityTransform(Unigine.Math.Mat4)">
			<summary>
			Sets a transformation matrix (in world coordinates) and computes linear and angular velocities of the body depending on its trajectory from the current position to the specified one. The time used in calculations corresponds to physics ticks. It clears forces and torques to zeros and nullifies counted down frozen frames.
			</summary> 
			<param name="transform"> Transformation matrix. This matrix describes position, orientation and scale of the body. </param> 
		</member>
		<member name="M:Unigine.Body.flushTransform const">
			<summary>
			Forces to set the transformations of the body for the node.
			</summary>  
		</member>
		<member name="M:Unigine.Body.setPosition(Unigine.Math.Vec3)">
			<summary>
			Updates the body position (in world coordinates). Body's linear and angular velocities will be reset to 0.
			</summary> 
			<param name="pos"> New position in the world coordinates. </param> 
		</member>
		<member name="M:Unigine.Body.getPosition const">
			<summary>
			Returns the body position (in world coordinates).
			</summary>  
			<returns>The body position in the world coordinates.</returns>
		</member>
		<member name="M:Unigine.Body.setRotation(Unigine.Math.quat)">
			<summary>
			Updates the body rotation (in world coordinates).
			</summary> 
			<param name="rot"> New rotation in the world coordinates. </param> 
		</member>
		<member name="M:Unigine.Body.getRotation const">
			<summary>
			Returns the body rotation (in world coordinates).
			</summary>  
			<returns>The body rotation in the world coordinates.</returns>
		</member>
		<member name="M:Unigine.Body.setDirection(Unigine.Math.vec3,Unigine.Math.vec3)">
			<summary>
			Updates the direction vector of the body (in world coordinates). By default, a direction vector points along -Z axis. This function changes its direction and reorients the body.
			</summary> 
			<param name="dir"> New direction vector in the world coordinates. The direction vector always has unit length. </param>
			<param name="up"> New up vector in the world coordinates. </param> 
		</member>
		<member name="M:Unigine.Body.getDirection const">
			<summary>
			Returns the normalized direction vector of the body (in world coordinates). By default, a direction vector points along -Z axis. It always has an unit length.
			</summary>  
			<returns>Normalized direction vector in the world coordinates.</returns>
		</member>
		<member name="M:Unigine.Body.getParent const">
			<summary>
			Returns the parent of the body.
			</summary>  
			<returns>Parent body.</returns>
		</member>
		<member name="M:Unigine.Body.isChild(Unigine.Ptr{Unigine.Body}) const">
			<summary>
			Checks if a given body is a child of the body.
			</summary> 
			<param name="body"> Body to check. </param> 
			<returns>1 if the provided body is a child; otherwise, 0. </returns>
		</member>
		<member name="M:Unigine.Body.getNumChildren const">
			<summary>
			Returns the number of child bodies.
			</summary>  
			<returns>Number of children.</returns>
		</member>
		<member name="M:Unigine.Body.findChild(char) const">
			<summary>
			Searches for a child body with a given name.
			</summary> 
			<param name="name"> Name of the child body. </param> 
			<returns>Number of the child in the list of children, if it is found; otherwise, -1. </returns>
		</member>
		<member name="M:Unigine.Body.getChild(int) const">
			<summary>
			Returns a given child body.
			</summary> 
			<param name="num"> Child number. </param> 
			<returns>Corresponding body.</returns>
		</member>
		<member name="M:Unigine.Body.addShape(Unigine.Ptr{Unigine.Shape},Unigine.Math.mat4)">
			<summary>
			Adds a shape to the list of shapes comprising the body.
			</summary> 
			<param name="shape"> New shape to add. </param>
			<param name="transform"> Shape transformation matrix (in the body's coordinate system). </param> 
		</member>
		<member name="M:Unigine.Body.addShape(Unigine.Ptr{Unigine.Shape})">
			<summary>
			Adds a shape to the list of shapes comprising the body.
			</summary> 
			<param name="shape"> New shape to add. </param> 
		</member>
		<member name="M:Unigine.Body.removeShape(Unigine.Ptr{Unigine.Shape},bool)">
			<summary>
			Removes a given shape from the body.
			</summary> 
			<param name="shape"> Shape to be removed. </param>
			<param name="destroy"> Flag indicating whether the shape is to be destroyed after removal: use 1 to destroy the shape after removal, or 0 if you plan to use the shape later. The default value is 0. </param> 
		</member>
		<member name="M:Unigine.Body.removeShape(int,bool)">
			<summary>
			Removes a shape with a given number from the body.
			</summary> 
			<param name="num"> Shape number. </param>
			<param name="destroy"> Flag indicating whether the shape is to be destroyed after removal: use 1 to destroy the shape after removal, or 0 if you plan to use the shape later. The default value is 0. </param> 
		</member>
		<member name="M:Unigine.Body.clearShapes(int)">
			<summary>
			Clears all shapes from the body.
			</summary> 
			<param name="destroy"> Flag indicating whether shapes are to be destroyed after removal: use 1 to destroy shapes after removal, or 0 if you plan to use them later. The default value is 0. </param> 
		</member>
		<member name="M:Unigine.Body.isShape(Unigine.Ptr{Unigine.Shape}) const">
			<summary>
			Checks if a given shape belongs to the body.
			</summary> 
			<param name="shape"> Shape to check. </param> 
			<returns>1 if the shape belongs to the body; otherwise, 0. </returns>
		</member>
		<member name="M:Unigine.Body.insertShape(int,Unigine.Ptr{Unigine.Shape})">
			<summary>
			Inserts a given shape at the specified position in the list of body's shapes.
			</summary> 
			<param name="pos"> Position in the list at which the shape is to be inserted in the range from 0 to the number of shapes. </param>
			<param name="shape"> Shape to be inserted. </param> 
			<returns>1 if a shape was successfully inserted; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Body.insertShape(int,Unigine.Ptr{Unigine.Shape},Unigine.Math.mat4)">
			<summary>
			Inserts a given shape at the specified position in the list of body's shapes and sets the specified transformation for it.
			</summary> 
			<param name="pos"> Position in the list at which the shape is to be inserted in the range from 0 to the number of shapes. </param>
			<param name="shape"> Shape to be inserted. </param>
			<param name="transform"> Shape's transformation (in the body's coordinate system). </param> 
			<returns>1 if a shape was successfully inserted; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Body.getNumShapes const">
			<summary>
			Returns the number of shapes comprising the body.
			</summary>  
			<returns>Number of shapes.</returns>
		</member>
		<member name="M:Unigine.Body.findShape(char) const">
			<summary>
			Searches for a shape with a given name.
			</summary> 
			<param name="name"> Name of the shape. </param> 
			<returns>Number of the shape in the list of shapes, if it is found; otherwise, -1. </returns>
		</member>
		<member name="M:Unigine.Body.getShape(int) const">
			<summary>
			Returns a given shape.
			</summary> 
			<param name="num"> Shape number. </param> 
			<returns>Corresponding shape object.</returns>
		</member>
		<member name="M:Unigine.Body.setShapeTransform(int,Unigine.Math.mat4)">
			<summary>
			Sets a transformation matrix for a given shape (in local coordinates). This matrix describes position and orientation of the shape.
			</summary> 
			<param name="num"> Shape number. </param>
			<param name="transform"> Transformation matrix (in the body's coordinate system). </param> 
		</member>
		<member name="M:Unigine.Body.getShapeTransform(int) const">
			<summary>
			Returns the transformation matrix of a given shape (in local coordinates). This matrix describes position and orientation of the shape.
			</summary> 
			<param name="num"> Shape number. </param> 
			<returns>Transformation matrix.</returns>
		</member>
		<member name="M:Unigine.Body.updateShapes">
			<summary>
			Updates all shapes of the body.
			</summary>  
		</member>
		<member name="M:Unigine.Body.addJoint(Unigine.Ptr{Unigine.Joint})">
			<summary>
			Adds a joint to the body.
			</summary> 
			<param name="joint"> New joint to add. </param> 
		</member>
		<member name="M:Unigine.Body.removeJoint(Unigine.Ptr{Unigine.Joint})">
			<summary>
			Removes a given joint from the body.
			</summary> 
			<param name="joint"> Joint to be removed. </param> 
		</member>
		<member name="M:Unigine.Body.removeJoint(int)">
			<summary>
			Removes a joint with a given number from the body.
			</summary> 
			<param name="num"> Joint number. </param> 
		</member>
		<member name="M:Unigine.Body.insertJoint(Unigine.Ptr{Unigine.Joint},int)">
			<summary>
			Inserts a given joint at the specified position in the list of body's joints.
			</summary> 
			<param name="joint"> Joint to be inserted. </param>
			<param name="num"> Position in the list at which the joint is to be inserted in the range from 0 to the number of joints. </param> 
		</member>
		<member name="M:Unigine.Body.isJoint(Unigine.Ptr{Unigine.Joint}) const">
			<summary>
			Checks if a given joint belongs to the body.
			</summary> 
			<param name="joint"> Joint to check. </param> 
			<returns>1 if the joint belongs to the body; otherwise, 0. </returns>
		</member>
		<member name="M:Unigine.Body.getNumJoints const">
			<summary>
			Returns the number of joints in the body.
			</summary>  
			<returns>Number of joints.</returns>
		</member>
		<member name="M:Unigine.Body.findJoint(char) const">
			<summary>
			Searches for a joint with a given name.
			</summary> 
			<param name="name"> Name of the joint. </param> 
			<returns>Number of the joint in the list of joints, if it is found; otherwise, -1. </returns>
		</member>
		<member name="M:Unigine.Body.getJoint(int) const">
			<summary>
			Returns a given joint.
			</summary> 
			<param name="num"> Joint number. </param> 
			<returns>Corresponding joint.</returns>
		</member>
		<member name="M:Unigine.Body.getIntersection(Unigine.Math.Vec3,Unigine.Math.Vec3,int,Unigine.Math.Vec3,Unigine.Math.vec3)">
			<summary>
								Performs tracing from the p0 point to the p1 point to find a body shape intersected by this line. Intersection is found only for objects with a matching intersection mask. On success ret_point and ret_normal shall contain information about intersection.					World space coordinates are used for this function.
			</summary> 
			<param name="p0"> Start point of the line (in world coordinates). </param>
			<param name="p1"> End point of the line (in world coordinates). </param>
			<param name="mask"> Intersection mask. </param>
			<param name="ret_point"> Container to which contact point coordinates (if any) shall be put (in world coordinate system). </param>
			<param name="ret_normal"> Container to which contact point normal coordinates (if any) shall be put (in world coordinate system). </param> 
			<returns>First intersected shape, if found; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Body.getNumContacts const">
			<summary>
			Returns the total number of contacts in which the body participates. It includes internal (handled by the body) and external contacts (handled by other bodies).
			</summary>  
			<returns>Number of contacts.</returns>
		</member>
		<member name="M:Unigine.Body.getContactID(int) const">
			<summary>
			Returns the contact ID by the contact number.
			</summary> 
			<param name="num"> Contact number in the range from 0 to the total number of contacts. </param> 
			<returns>Contact ID.</returns>
		</member>
		<member name="M:Unigine.Body.findContactByID(unsignedlonglong) const">
			<summary>
			Returns the number of the contact by its ID.
			</summary> 
			<param name="id"> Contact ID. </param> 
			<returns>Number of the contact with the specified ID if it exists, otherwise -1.</returns>
		</member>
		<member name="M:Unigine.Body.isContactInternal(int) const">
			<summary>
			Returns a value indicating whether the contact with the specified number is internal (handled by the body) or not (handled by another body). A contact can be handled by any of the bodies that participate in it. To which body a contact is assigned is random. If the contact is assigned to and handled by the body it is called an internal one, otherwise it is called external (handled by another body). The total number of contacts for the body includes all, internal and external ones. Iterating through internal contacts is much faster than through external ones, thus you might want a certain body to handle most of the contacts it participates in. This can be done for a rigid body by raising a priority for the body via the setHighPriorityContacts() method.
			</summary> 
			<param name="num"> Contact number in the range from 0 to the total number of contacts. </param> 
			<returns>true if the contact contact with the specified number is internal; otherwise false.</returns>
		</member>
		<member name="M:Unigine.Body.isContactEnter(int) const">
			<summary>
			Returns a value indicating if the body has begun touching another body at the contact point with the specified number (the contact has just occurred).
			</summary> 
			<param name="num"> Contact number in the range from 0 to the total number of contacts. </param> 
			<returns>true if the body has begun touching another body at the contact point with the specified number (the contact has just occurred); otherwise false.</returns>
		</member>
		<member name="M:Unigine.Body.isContactLeave(int) const">
			<summary>
			Returns a value indicating if the body has stopped touching another body at the contact point with the specified number.
			</summary> 
			<param name="num"> Contact number in the range from 0 to the total number of contacts. </param> 
			<returns>true if the body has stopped touching another body at the contact point with the specified number; otherwise false.</returns>
		</member>
		<member name="M:Unigine.Body.isContactStay(int) const">
			<summary>
			Returns a value indicating if the body keeps touching another body at the contact point with the specified number (the contact lasts).
			</summary> 
			<param name="num"> Contact number in the range from 0 to the total number of contacts. </param> 
			<returns>true if the body keeps touching another body at the contact point with the specified number (the contact lasts); otherwise false.</returns>
		</member>
		<member name="M:Unigine.Body.getContactPoint(int) const">
			<summary>
			Returns world coordinates of the contact point.
			</summary> 
			<param name="num"> Contact number in the range from 0 to the total number of contacts. </param> 
			<returns>Contact point (in world coordinates).</returns>
		</member>
		<member name="M:Unigine.Body.getContactNormal(int) const">
			<summary>
			Returns a normal of the contact point, in world coordinates.
			</summary> 
			<param name="num"> Contact number in the range from 0 to the total number of contacts. </param> 
			<returns>Contact normal (in world coordinates).</returns>
		</member>
		<member name="M:Unigine.Body.getContactVelocity(int) const">
			<summary>
			Returns relative velocity at the given contact point.
			</summary> 
			<param name="num"> Contact number in the range from 0 to the total number of contacts. </param> 
			<returns>Velocity vector.</returns>
		</member>
		<member name="M:Unigine.Body.getContactImpulse(int) const">
			<summary>
			Returns the relative impulse at the given contact point.
			</summary> 
			<param name="num"> Contact number in the range from 0 to the total number of contacts. </param> 
			<returns>Impulse value.</returns>
		</member>
		<member name="M:Unigine.Body.getContactTime(int) const">
			<summary>
			Returns the time when the given contact occurs. By CCD (for spheres or capsules), it returns the time starting from the current physics simulation tick to the moment when the calculated contact is bound to happen. By non-continuous collision detection, 0 is always returned.
			</summary> 
			<param name="num"> Contact number in the range from 0 to the total number of contacts. </param> 
			<returns>Time of the calculated contact to happen, in seconds.</returns>
		</member>
		<member name="M:Unigine.Body.getContactDepth(int) const">
			<summary>
			Returns the depth by which the body penetrated with an obstacle by the given contact. This distance is measured along the contact normal.
			</summary> 
			<param name="num"> Contact number in the range from 0 to the total number of contacts. </param> 
			<returns>Penetration depth, in units.</returns>
		</member>
		<member name="M:Unigine.Body.getContactFriction(int) const">
			<summary>
			Returns relative friction at the given contact point.
			</summary> 
			<param name="num"> Contact number in the range from 0 to the total number of contacts. </param> 
			<returns>Friction value.</returns>
		</member>
		<member name="M:Unigine.Body.getContactRestitution(int) const">
			<summary>
			Returns relative restitution at the given contact point.
			</summary> 
			<param name="num"> Contact number in the range from 0 to the total number of contacts. </param> 
			<returns>Restitution.</returns>
		</member>
		<member name="M:Unigine.Body.getContactBody0(int) const">
			<summary>
			Returns the first body participating in a given contact. This is not necessarily the current body.
			</summary> 
			<param name="num"> Contact number in the range from 0 to the total number of contacts. </param> 
			<returns>First body.</returns>
		</member>
		<member name="M:Unigine.Body.getContactBody1(int) const">
			<summary>
			Returns the second body participating in a given contact. This is not necessarily the current body.
			</summary> 
			<param name="num"> Contact number in the range from 0 to the total number of contacts. </param> 
			<returns>Second body.</returns>
		</member>
		<member name="M:Unigine.Body.getContactShape0(int) const">
			<summary>
			Returns the first shape participating in a given contact. This shape does not necessarily belong to the current body.
			</summary> 
			<param name="num"> Contact number in the range from 0 to the total number of contacts. </param> 
			<returns>First shape.</returns>
		</member>
		<member name="M:Unigine.Body.getContactShape1(int) const">
			<summary>
			Returns the second shape participating in a given contact. This shape does not necessarily belong to the current body.
			</summary> 
			<param name="num"> Contact number in the range from 0 to the total number of contacts. </param> 
			<returns>Second shape.</returns>
		</member>
		<member name="M:Unigine.Body.getContactObject(int) const">
			<summary>
			Returns an object participating in the contact (used for collisions with non-physical object).
			</summary> 
			<param name="num"> Contact number in the range from 0 to the total number of contacts. </param> 
			<returns>Object in contact.</returns>
		</member>
		<member name="M:Unigine.Body.getContactSurface(int) const">
			<summary>
			Returns the surface of the current object, which is in contact (used for collisions with non-physical object).
			</summary> 
			<param name="num"> Contact number in the range from 0 to the total number of contacts. </param> 
			<returns>Surface number.</returns>
		</member>
		<member name="M:Unigine.Body.addFrozenCallback(Unigine.CallbackBase1{Unigine.Ptr{Unigine.Body}})">
			<summary>
			Adds a callback function to be called when a given body freezes.  The signature of the frozen callback function must be as follows:					You can set a callback function as follows:					Physics-based callbacks are executed in the main tread, as they are mainly used for creation, destruction or modification of other objects.					Example: Setting a body frozen callback function for a certain class:
			</summary> 
			<param name="func"> Callback pointer. </param> 
			<returns>ID of the last added frozen callback, if the callback was added successfully; otherwise, nullptr. This ID can be used to remove this callback when necessary.</returns>
		</member>
		<member name="M:Unigine.Body.removeFrozenCallback(void)">
			<summary>
			Removes the specified callback from the list of frozen callbacks.
			</summary> 
			<param name="id"> Frozen callback ID obtained when adding it. </param> 
			<returns>True if the frozen callback with the given ID was removed successfully; otherwise false.</returns>
		</member>
		<member name="M:Unigine.Body.clearFrozenCallbacks">
			<summary>
			Clears all added frozen callbacks.
			</summary>  
		</member>
		<member name="M:Unigine.Body.addPositionCallback(Unigine.CallbackBase1{Unigine.Ptr{Unigine.Body}})">
			<summary>
			Adds a callback function to be called when a given body moves a certain distance (rotation is not taken into account). The signature of the position callback function must be as follows:					You can set a callback function as follows:					Physics-based callbacks are executed in the main tread, as they are mainly used for creation, destruction or modification of other objects.					Example: Setting a body position callback function for a certain class:
			</summary> 
			<param name="func"> Callback pointer. </param> 
			<returns>ID of the last added position callback, if the callback was added successfully; otherwise, nullptr. This ID can be used to remove this callback when necessary.</returns>
		</member>
		<member name="M:Unigine.Body.removePositionCallback(void)">
			<summary>
			Removes the specified callback from the list of position callbacks.
			</summary> 
			<param name="id"> Position callback ID obtained when adding it. </param> 
			<returns>True if the position callback with the given ID was removed successfully; otherwise false.</returns>
		</member>
		<member name="M:Unigine.Body.clearPositionCallbacks">
			<summary>
			Clears all added position callbacks.
			</summary>  
		</member>
		<member name="M:Unigine.Body.addContactsCallback(Unigine.CallbackBase1{Unigine.Ptr{Unigine.Body}})">
			<summary>
			Adds a callback function to be called after adding new contacts and before removing the ones that cease to exist. This callback can be used to get all contacts of the body including new ones (enter) and the ending ones (leave). Leave contacts are removed after the callback execution stage, so this is the only point where you can still get them.					The signature of the contacts callback function must be as follows:					You can set a callback function as follows:					Example: Setting a body contacts callback function for a certain class:					Physics-based callbacks are executed in the main tread, as they are mainly used for creation, destruction or modification of other objects.
			</summary> 
			<param name="func"> Callback pointer. </param> 
			<returns>ID of the last added contact callback, if the callback was added successfully; otherwise, nullptr. This ID can be used to remove this callback when necessary.</returns>
		</member>
		<member name="M:Unigine.Body.removeContactsCallback(void)">
			<summary>
			Removes the specified callback from the list of contacts callbacks. This callback is called after adding new contacts and before removing the ones that cease to exist. It can be used to get all contacts of the body including new ones (enter) and the ending ones (leave). Leave contacts are removed after the callback execution stage, so this is the only point where you can still get them.
			</summary> 
			<param name="id"> Contact callback ID obtained when adding it. </param> 
			<returns>true if the contacts callback with the given ID was removed successfully; otherwise false.</returns>
		</member>
		<member name="M:Unigine.Body.clearContactsCallbacks">
			<summary>
			Clears all added contacts callbacks. This callback is called after adding new contacts and before removing the ones that cease to exist. It can be used to get all contacts of the body including new ones (enter) and the ending ones (leave). Leave contacts are removed after the callback execution stage, so this is the only point where you can still get them.
			</summary>  
		</member>
		<member name="M:Unigine.Body.addContactEnterCallback(Unigine.CallbackBase2{Unigine.Ptr{Unigine.Body},int})">
			<summary>
			Adds a callback function to be called when a contact with the body emerges (the body begins touching another body). 					The signature of the callback function must be as follows:					You can set a callback function as follows:					Example: Setting a body contact enter callback function for a certain class:					Physics-based callbacks are executed in the main tread, as they are mainly used for creation, destruction or modification of other objects.
			</summary> 
			<param name="func"> Callback pointer. </param> 
			<returns>ID of the last added contact enter callback, if the callback was added successfully; otherwise, nullptr. This ID can be used to remove this callback when necessary.</returns>
		</member>
		<member name="M:Unigine.Body.removeContactEnterCallback(void)">
			<summary>
			Removes the specified callback from the list of contact enter callbacks. These callbacks are called when a contact with the body emerges (the body begins touching another body).
			</summary> 
			<param name="id"> Contact callback ID obtained when adding it. </param> 
			<returns>true if the contact enter callback with the given ID was removed successfully; otherwise false.</returns>
		</member>
		<member name="M:Unigine.Body.clearContactEnterCallbacks">
			<summary>
			Clears all added contact enter callbacks. These callbacks are called when a contact with the body emerges (the body begins touching another body).
			</summary>  
		</member>
		<member name="M:Unigine.Body.addContactLeaveCallback(Unigine.CallbackBase2{Unigine.Ptr{Unigine.Body},int})">
			<summary>
			Adds a callback function to be called when a contact with the body ends (the body stops touching another body). 					The signature of the callback function must be as follows:					You can set a callback function as follows:					Example: Setting a body contact leave callback function for a certain class:					Physics-based callbacks are executed in the main tread, as they are mainly used for creation, destruction or modification of other objects.
			</summary> 
			<param name="func"> Callback pointer. </param> 
			<returns>ID of the last added contact leave callback, if the callback was added successfully; otherwise, nullptr. This ID can be used to remove this callback when necessary.</returns>
		</member>
		<member name="M:Unigine.Body.removeContactLeaveCallback(void)">
			<summary>
			Removes the specified callback from the list of contact leave callbacks. These callbacks are called when a contact with the body ends (the body stops touching another body).
			</summary> 
			<param name="id"> Contact callback ID obtained when adding it. </param> 
			<returns>true if the contact leave callback with the given ID was removed successfully; otherwise false.</returns>
		</member>
		<member name="M:Unigine.Body.clearContactLeaveCallbacks">
			<summary>
			Clears all added contact leave callbacks. These callbacks are called when a contact with the body ends (the body stops touching another body).
			</summary>  
		</member>
		<member name="M:Unigine.Body.renderContacts">
			<summary>
			Renders all contact points of the body including internal and external ones (handled by other bodies).					You should enable the engine visualizer via the show_visualizer 1 console command.
			</summary>  
		</member>
		<member name="M:Unigine.Body.renderExternalContacts">
			<summary>
			Renders all external contacts of the body (handled by other bodies).					You should enable the engine visualizer via the show_visualizer 1 console command.
			</summary>  
		</member>
		<member name="M:Unigine.Body.renderInternalContacts">
			<summary>
			Renders all internal contacts of the body (handled by it).					You should enable the engine visualizer via the show_visualizer 1 console command.
			</summary>  
		</member>
		<member name="M:Unigine.Body.renderJoints">
			<summary>
			Renders joints to which the body is connected.					You should enable the engine visualizer via the show_visualizer 1 console command.
			</summary>  
		</member>
		<member name="M:Unigine.Body.renderShapes">
			<summary>
			Renders shapes comprising the body.					You should enable the engine visualizer via the show_visualizer 1 console command.
			</summary>  
		</member>
		<member name="M:Unigine.Body.renderVisualizer">
			<summary>
			Renders shapes, joints and contact points of the body.					You should enable the engine visualizer via the show_visualizer 1 console command.
			</summary>  
		</member>
		<member name="M:Unigine.Body.clone(Unigine.Ptr{Unigine.Object}) const">
			<summary>
			Clones the body and assigns a copy to a given object.
			</summary> 
			<param name="object"> Object, to which the copy will be assigned. </param> 
			<returns>Copy of the body.</returns>
		</member>
		<member name="M:Unigine.Body.swap(Unigine.Ptr{Unigine.Body}) const">
			<summary>
			Swaps the bodies saving the pointers.
			</summary> 
			<param name="body"> Body to swap. </param> 
		</member>
		<member name="M:Unigine.Body.saveState(Unigine.Ptr{Unigine.Stream}) const">
			<summary>
			Saves the state of a given body into a binary stream.					Example using saveState() and restoreState() methods:
			</summary> 
			<param name="stream"> Stream to save body state data. </param> 
			<returns>true if the body state is successfully saved; otherwise, false.</returns>
		</member>
		<member name="M:Unigine.Body.restoreState(Unigine.Ptr{Unigine.Stream})">
			<summary>
			Restores the state of a given body from a binary stream.					Example using saveState() and restoreState() methods:
			</summary> 
			<param name="stream"> Stream with saved body state data. </param> 
			<returns>true if the body state is successfully restored; otherwise, false.</returns>
		</member>
		<member name="F:Unigine.Body.BODY_CLOTH">
			<summary>
			This body simulates cloth.
		</summary>
		</member>
		<member name="F:Unigine.Body.BODY_DUMMY">
			<summary>
			This body is used to create an immovable collider for an object.
		</summary>
		</member>
		<member name="F:Unigine.Body.BODY_FRACTURE">
			<summary>
			This body simulates breakable objects.
		</summary>
		</member>
		<member name="F:Unigine.Body.BODY_PATH">
			<summary>
			This body simulates a path along which rigid bodies are moving, for example, like a train along the railtrack.
		</summary>
		</member>
		<member name="F:Unigine.Body.BODY_RAGDOLL">
			<summary>
			This body contains joints connecting parts of the body (represented with rigid bodies).
		</summary>
		</member>
		<member name="F:Unigine.Body.BODY_RIGID">
			<summary>
			This is a basic type of body describing a rigid object.
		</summary>
		</member>
		<member name="F:Unigine.Body.BODY_ROPE">
			<summary>
			This body simulates ropes.
		</summary>
		</member>
		<member name="F:Unigine.Body.BODY_WATER">
			<summary>
			This body simulates water and other fluids.
		</summary>
		</member>
		<member name="F:Unigine.Body.NUM_BODIES">
			<summary>
			The number of bodies.
		</summary>
		</member>
		<member name="M:Unigine.BodyCloth.#ctor">
			<summary>
			Constructor. Creates a cloth body with default properties.
			</summary>  
		</member>
		<member name="M:Unigine.BodyCloth.#ctor(Unigine.Ptr{Unigine.Object})">
			<summary>
			Constructor. Creates a cloth body with default properties for a given object.
			</summary> 
			<param name="object"> Object represented with the new cloth body. </param> 
		</member>
		<member name="M:Unigine.BodyCloth.getNumIndices">
			<summary>
			Returns the number of particle indices.
			</summary>  
			<returns>Number of particle indices.</returns>
		</member>
		<member name="M:Unigine.BodyCloth.getParticleIndex(int)">
			<summary>
			Returns the particle index by its number.
			</summary> 
			<param name="num"> The particle index number. </param> 
			<returns>The particle index.</returns>
		</member>
		<member name="M:Unigine.BodyCloth.setTwoSided(int)">
			<summary>
			Set a value indicating if the cloth is one- or two-sided. (If two-sided, its material should not be two-sided at the same time).
			</summary> 
			<param name="sided"> Positive value, if the cloth should be two-sided; 0 if one-sided. </param> 
		</member>
		<member name="M:Unigine.BodyCloth.getTwoSided">
			<summary>
			Returns a value indicating if the cloth is one- or two-sided. (If two-sided, its material should not be two-sided at the same time).
			</summary>  
			<returns>1 if the cloth is rendered one-sided; 0 if one-sided.</returns>
		</member>
		<member name="M:Unigine.BodyDummy.#ctor">
			<summary>
			Constructor. Creates a dummy body.
			</summary>  
		</member>
		<member name="M:Unigine.BodyDummy.#ctor(Unigine.Ptr{Unigine.Object})">
			<summary>
			Constructor. Creates a dummy body for a given object.
			</summary> 
			<param name="object"> Object approximated with the new dummy body. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.#ctor">
			<summary>
			Constructor. Creates a fracture body with default properties.
			</summary>  
		</member>
		<member name="M:Unigine.BodyFracture.#ctor(Unigine.Ptr{Unigine.Object})">
			<summary>
			Constructor. Creates a fracture body with default properties for a given object.
			</summary> 
			<param name="object"> Object represented with the new fracture body. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.setAngularDamping(float)">
			<summary>
			Sets the damping of the body angular velocity.
			</summary> 
			<param name="damping"> Angular damping value. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.getAngularDamping const">
			<summary>
			Returns the current damping of the body angular velocity.
			</summary>  
			<returns>Angular damping value.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.getBodyRigid const">
			<summary>
			Returns an internal body rigid body that represents fracture body until it is broken.
			</summary>  
			<returns>Internal body rigid.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.setBroken(bool)">
			<summary>
			Sets a value indicating if the object is broken or remains its solid state.
			</summary> 
			<param name="broken"> Positive number to indicate the object as broken; 0 for it to remain solid. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.isBroken const">
			<summary>
			Returns a value indicating if the object is broken or remains its solid state.
			</summary>  
			<returns>Positive number if the object is already broken; 0 if it is still solid.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.setCollisionMask(int)">
			<summary>
			Sets a collision bit mask for the body. Two objects collide, if they both have matching masks. See also details on additional collision exclusion mask.
			</summary> 
			<param name="mask"> Integer, each bit of which is a mask. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.getCollisionMask const">
			<summary>
			Returns the collision bit mask for the body. Two objects collide, if they both have matching masks. See also details on additional collision exclusion mask.
			</summary>  
			<returns>Integer, each bit of which is a mask.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.setDensity(float)">
			<summary>
			Sets density of a body. Changing the density influences the mass, that is computed by multiplying body volume by density.
			</summary> 
			<param name="density"> Density of the body. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.getDensity const">
			<summary>
			Returns the current density of the body.
			</summary>  
			<returns>Density of the body.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.setError(float)">
			<summary>
			Sets approximation error permissible by creating convex shape for the mesh.
			</summary> 
			<param name="error"> Approximation error. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.getError const">
			<summary>
			Returns the current approximation error permissible by creating convex shape for the mesh.
			</summary>  
			<returns>Approximation error.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.setExclusionMask(int)">
			<summary>
			Sets a bit mask to prevent collisions of the body with other ones. This mask is independent of the collision mask. For bodies with matching collision masks not to collide, at least one bit of their exclusion mask should match. 0 is to collide with all bodies with a matching collision mask.
			</summary> 
			<param name="mask"> Integer, each bit of which is a mask. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.getExclusionMask const">
			<summary>
			Returns the bit mask that prevents collisions of the body with other ones. This mask is independent of the collision mask. For bodies with matching collision masks not to collide, at least one bit of their exclusion mask should match.
			</summary>  
			<returns>Integer, each bit of which is a mask.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.setFriction(float)">
			<summary>
			Sets friction of the body against other surfaces.
			</summary> 
			<param name="friction"> Friction value. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.getFriction const">
			<summary>
			Returns the current friction of the body against other surfaces.
			</summary>  
			<returns>Friction value.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.setFrozenAngularVelocity(float)">
			<summary>
			Sets angular velocity threshold for freezing body simulation. If body angular velocity remains lower than this threshold during the number of Frozen frames (together with linear one), it stops to be updated.
			</summary> 
			<param name="velocity"> "Freeze" angular velocity. If the value is lower than the engine.physics.setFrozenAngularVelocity one, it is overridden. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.getFrozenAngularVelocity const">
			<summary>
			Returns the current angular velocity threshold for freezing body simulation. If body angular velocity remains lower than this threshold during the number of Frozen frames (together with linear one), it stops to be updated.
			</summary>  
			<returns>"Freeze" angular velocity.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.setFrozenLinearVelocity(float)">
			<summary>
			Sets linear velocity threshold for freezing body simulation. If body linear velocity remains lower than this threshold during the number of Frozen frames (together with angular one), it stops to be updated.
			</summary> 
			<param name="velocity"> "Freeze" linear velocity. If the value is lower than the engine.physics.setFrozenLinearVelocity one, it is overridden. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.getFrozenLinearVelocity const">
			<summary>
			Returns the current linear velocity threshold for freezing body simulation. If body linear velocity remains lower than this threshold during the number of Frozen frames (together with angular one), it stops to be updated.
			</summary>  
			<returns>"Freeze" linear velocity.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.setPhysicsIntersectionMask(int)">
			<summary>
			Sets a physics intersection mask for the body.
			</summary> 
			<param name="mask"> Integer, each bit of which is a mask. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.getPhysicsIntersectionMask const">
			<summary>
			Returns the current physics intersection mask for the body.
			</summary>  
			<returns>Integer, each bit of which is a mask.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.setLinearDamping(float)">
			<summary>
			Sets the damping of the body linear velocity.
			</summary> 
			<param name="damping"> Linear damping value. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.getLinearDamping const">
			<summary>
			Returns the current damping of the body linear velocity.
			</summary>  
			<returns>Linear damping value.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.setMass(float)">
			<summary>
			Sets a mass of the body. Changing the mass influences the density, that is computed by dividing the mass by body volume.
			</summary> 
			<param name="mass"> Mass of the body. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.getMass const">
			<summary>
			Returns the current mass of the body.
			</summary>  
			<returns>Mass of the body.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.setMaterial(Unigine.Ptr{Unigine.Material})">
			<summary>
			Sets the material for fractured verge surfaces appearing after breaking the body.
			</summary> 
			<param name="material"> Material smart pointer. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.getMaterial const">
			<summary>
			Returns the material for fractured verge surfaces appearing after breaking the body.
			</summary>  
			<returns>Smart pointer for the material of the fractured verges.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.setMaxAngularVelocity(float)">
			<summary>
			Sets the maximum possible linear velocity for the body. If the value is lower than the engine.physics.setMaxAngularVelocity one, it is overridden.
			</summary> 
			<param name="velocity"> Maximum possible angular velocity. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.getMaxAngularVelocity const">
			<summary>
			Returns the current maximum possible angular velocity for the body. If the value is lower than the engine.physics.setMaxAngularVelocity one, it is overridden.
			</summary>  
			<returns>Maximum possible angular velocity.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.setMaxLinearVelocity(float)">
			<summary>
			Sets the maximum possible linear velocity for the body. If the value is lower than the engine.physics.setMaxLinearVelocity one, it is overridden.
			</summary> 
			<param name="velocity"> Maximum possible linear velocity. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.getMaxLinearVelocity const">
			<summary>
			Returns the current maximum possible linear velocity for the body. If the value is lower than the engine.physics.setMaxLinearVelocity one, it is overridden.
			</summary>  
			<returns>Maximum possible linear velocity.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.setSurfaceProperty(char)">
			<summary>
			Sets the property for cracked verge surfaces appearing after breaking the body.
			</summary> 
			<param name="property"> Property name for the fractured verges. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.getSurfaceProperty const">
			<summary>
			Returns the property for fractured verge surfaces appearing after breaking the body.
			</summary>  
			<returns>Property name for the fractured verges.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.setRestitution(float)">
			<summary>
			Sets the restitution that determines body bouncing off the surfaces.
			</summary> 
			<param name="restitution"> Restitution value. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.getRestitution const">
			<summary>
			Returns the current restitution that determines body bouncing off the surfaces.
			</summary>  
			<returns>Restitution value.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.setThreshold(float)">
			<summary>
			Sets the minimum volume threshold for breaking. If the piece volume is less than the threshold value, it cannot be fractured further.
			</summary> 
			<param name="threshold"> Volume threshold. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.getThreshold const">
			<summary>
			Returns the current minimum volume threshold for breaking. If the piece volume is less than the threshold value, it cannot be fractured further.
			</summary>  
			<returns>Volume threshold.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.getVelocity(Unigine.Math.vec3) const">
			<summary>
			Returns the total linear velocity in the point determined by a given radius vector, specified in the local coordinates.
			</summary> 
			<param name="radius"> Radius vector starting in the body's center of mass. </param> 
			<returns>Total linear velocity in the given point.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.getWorldVelocity(Unigine.Math.Vec3) const">
			<summary>
			Returns the total linear velocity in the point specified in world coordinates.
			</summary> 
			<param name="point"> Point of the body in world coordinates. </param> 
			<returns>Total linear velocity in the given point.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.addForce(Unigine.Math.vec3) const">
			<summary>
								Applies a force to the center of mass of the body.					Unlike impulses, all forces are accumulated first, then the resulting force is calculated and applied to the body (during the physics simulation stage, when the body update() function is called).					You can call this function only from updatePhysics() function in the world script. Do not apply forces in the update() function, because you will get unstable result that varies each rendering frame.
			</summary> 
			<param name="force"> Force to be applied, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.addForce(Unigine.Math.vec3,Unigine.Math.vec3) const">
			<summary>
								Applies a force to a point determined by a given radius vector, specified in the local coordinates. This function calculates the cross product of the radius vector and the force vector. It acts like a lever arm that changes both linear and angular velocities of the body.					Unlike impulses, all forces are accumulated first, then the resulting force is calculated and applied to the body (during the physics simulation stage, when the body update() function is called).					You can call this function only from updatePhysics() function in the world script. Do not apply forces in the update() function, because you will get unstable result that varies each rendering frame.
			</summary> 
			<param name="radius"> Radius vector, traced from the center of mass of the body to the point where the force is applied, in local coordinates. </param>
			<param name="force"> Force to be applied, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.addImpulse(Unigine.Math.vec3,Unigine.Math.vec3)">
			<summary>
								Applies an impulse to a point determined by a given radius vector, specified in the local coordinates.					Unlike forces, impulses immediately affect both linear and angular velocities of the body.
			</summary> 
			<param name="radius"> Radius vector, traced from the center of mass to the point where the impulse is applied, in local coordinates. </param>
			<param name="impulse"> Impulse to be applied, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.addTorque(Unigine.Math.vec3) const">
			<summary>
								Applies a torque with a pivot point at the center of mass of the body, specified in the local coordinates.					All torque values are accumulated first, then the resulting torque is calculated and applied to the body (during the physics simulation stage, when the body update is called).					You can call this function only from updatePhysics() function in the world script. Do not apply torques in the update() function, because you will get unstable result that varies each rendering frame.
			</summary> 
			<param name="torque"> Torque to be applied, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.addTorque(Unigine.Math.vec3,Unigine.Math.vec3) const">
			<summary>
								Applies a torque with a pivot point, determined by a given radius vector, specified in the local coordinates.					This function calculates the cross product of the radius vector and the force vector.					It acts like a lever arm that changes both angular and linear velocities of the body.					All torque values are accumulated first, then the resulting torque is calculated and applied to the body (during the physics simulation stage, when the body update is called).					You can call this function only from updatePhysics() function in the world script. Do not apply torques in the update() function, because you will get unstable result that varies each rendering frame.
			</summary> 
			<param name="radius"> Radius vector starting at the body's center of mass, in local coordinates. Its end is the pivot point for the torque to be applied. </param>
			<param name="torque"> Torque to be applied, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.addWorldForce(Unigine.Math.Vec3,Unigine.Math.vec3)">
			<summary>
								Applies a force to a given point of the body that is specified in world coordinates. This function calculates the cross product of the radius vector (a vector from the center of mass to the point where force is applied) and the force vector. It acts like a lever arm that changes both linear and angular velocities of the body.					Unlike impulses, all forces are accumulated first, then the resulting force is calculated and applied to the body (during the physics simulation stage, when the body update is called).					You can call this function only from updatePhysics() function in the world script. Do not apply forces in the update() function, because you will get unstable result that varies each rendering frame.
			</summary> 
			<param name="point"> Point of the body in world coordinates. </param>
			<param name="force"> Force to be applied, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.addWorldImpulse(Unigine.Math.Vec3,Unigine.Math.vec3)">
			<summary>
			Applies an impulse to a given point of the body, that is specified in world coordinates. Unlike forces, impulses immediately affect both linear and angular velocities of the body.
			</summary> 
			<param name="point"> Point of the body in world coordinates. </param>
			<param name="impulse"> Impulse to be applied, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.addWorldTorque(Unigine.Math.Vec3,Unigine.Math.vec3)">
			<summary>
								Applies a torque with a pivot point at a given point of the body, that is specified in world coordinates. This function calculates the cross product of the radius vector (a vector from the center of mass to the pivot point) and the torque vector. It acts like a lever arm that changes both angular and linear velocities of the body.					All torque values are accumulated first, then the resulting torque is calculated and applied to the body (during the physics simulation stage, when the body update is called).					You can call this function only from updatePhysics() function in the world script. Do not apply torques in the update() function, because you will get unstable result that varies each rendering frame.
			</summary> 
			<param name="point"> Point of the body in world coordinates. </param>
			<param name="torque"> Torque to be applied, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.createCrackPieces(Unigine.Math.Vec3,Unigine.Math.vec3,int,int,float)">
			<summary>
			Breaks the object into radial cracks combined with concentric splits. If the first concentric split is rendered further than the specified step distance, decrease the volume threshold value.
			</summary> 
			<param name="point"> Point of contact. </param>
			<param name="normal"> Normal of the contact point. </param>
			<param name="num_cuts"> Number of radial cuts that are represented as rays coming from the center of contact point. </param>
			<param name="num_rings"> Number of rings that form concentric splits. The number of rings that is will be actually rendered depends on the step value. </param>
			<param name="step"> Distance between concentric splits. </param> 
			<returns>Positive number if the object was successfully broken; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.createShatterPieces(int)">
			<summary>
			Breaks the object into arbitrary shattered pieces.
			</summary> 
			<param name="num_pieces"> The number of shattered pieces. </param> 
			<returns>Positive number if the object was successfully broken; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.createSlicePieces(Unigine.Math.Vec3,Unigine.Math.vec3)">
			<summary>
			Breaks the object into two slices, slitting the body according to the normal of the specified point.
			</summary> 
			<param name="point"> Point of contact. </param>
			<param name="normal"> Normal of the contact point. </param> 
			<returns>Positive number if the object was successfully broken; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.setMaterialPath(char)">
			<summary>
			Sets the material for fractured verge surfaces by path.
			</summary> 
			<param name="path"> Material path. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.getMaterialPath const">
			<summary>
			Returns the path of the material for fractured verge surfaces.
			</summary>  
			<returns>Material path.</returns>
		</member>
		<member name="M:Unigine.BodyFracture.setMaterialGUID(Unigine.UGUID)">
			<summary>
			Sets the material for fractured verge surfaces by GUID.
			</summary> 
			<param name="materialguid"> Material GUID. </param> 
		</member>
		<member name="M:Unigine.BodyFracture.getMaterialGUID const">
			<summary>
			Returns the GUID of the material for fractured verge surfaces.
			</summary>  
			<returns>Material GUID.</returns>
		</member>
		<member name="M:Unigine.BodyParticles.setAngularRestitution(float)">
			<summary>
			Sets the restitution of the body's inner joints, when triangles formed by particles are folded angularly relative to each other.
			</summary> 
			<param name="restitution"> Joints angular restitution. Provided value is saturated in range [0;1.0]. </param> 
		</member>
		<member name="M:Unigine.BodyParticles.getAngularRestitution const">
			<summary>
			Returns the current restitution of the body's inner joints, when triangles formed by particles are folded angularly relative to each other.
			</summary>  
			<returns>Joints angular restitution.</returns>
		</member>
		<member name="M:Unigine.BodyParticles.setAngularThreshold(float)">
			<summary>
			Sets the threshold for angular folding of particles triangles connected by inner joints. When passing this threshold, the joints tear up.
			</summary> 
			<param name="threshold"> Joints angular folding threshold. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.BodyParticles.getAngularThreshold const">
			<summary>
			Returns the current threshold for angular folding of particles triangles connected by inner joints. When passing this threshold, the joints tear up.
			</summary>  
			<returns>Joints angular folding threshold.</returns>
		</member>
		<member name="M:Unigine.BodyParticles.setCollision(int)">
			<summary>
			Sets a value indicating if collision with a body is enabled or not.
			</summary> 
			<param name="collision"> Positive value to enable collision, 0 to disable it. </param> 
		</member>
		<member name="M:Unigine.BodyParticles.getCollision const">
			<summary>
			Returns a value indicating if collision with a body is enabled or not.
			</summary>  
			<returns>Positive value if collision is enabled, 0 if disabled.</returns>
		</member>
		<member name="M:Unigine.BodyParticles.setCollisionMask(int)">
			<summary>
			Sets a collision bit mask for the body. Two objects collide, if they both have matching masks.
			</summary> 
			<param name="mask"> Integer, each bit of which is a mask. </param> 
		</member>
		<member name="M:Unigine.BodyParticles.getCollisionMask const">
			<summary>
			Returns a collision bit mask for the body. Two objects collide, if they both have matching masks.
			</summary>  
			<returns>Integer, each bit of which is a mask.</returns>
		</member>
		<member name="M:Unigine.BodyParticles.setDistance(float)">
			<summary>
			Sets the distance of body simulation.
			</summary> 
			<param name="distance"> Distance of simulation. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.BodyParticles.getDistance const">
			<summary>
			Returns the current distance of body simulation.
			</summary>  
			<returns>Distance of simulation.</returns>
		</member>
		<member name="M:Unigine.BodyParticles.setFriction(float)">
			<summary>
			Sets the friction of the body by its contact with other surfaces.
			</summary> 
			<param name="friction"> Body friction. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.BodyParticles.getFriction const">
			<summary>
			Returns the current friction of the body by its contact with other surfaces.
			</summary>  
			<returns>Body friction.</returns>
		</member>
		<member name="M:Unigine.BodyParticles.setLinearDamping(float)">
			<summary>
			Sets a value indicating how much the linear velocity of the particles decreases over time.
			</summary> 
			<param name="damping"> Linear damping value. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.BodyParticles.getLinearDamping const">
			<summary>
			Returns a value indicating how much the linear velocity of the particles decreases over time.
			</summary>  
			<returns>Linear damping value.</returns>
		</member>
		<member name="M:Unigine.BodyParticles.setLinearRestitution(float)">
			<summary>
			Sets the restitution of the body's inner joints by linear stretching.
			</summary> 
			<param name="restitution"> Joints linear restitution. Provided value is saturated in range [0;1.0]. </param> 
		</member>
		<member name="M:Unigine.BodyParticles.getLinearRestitution const">
			<summary>
			Returns the current restitution of the body's inner joints by linear stretching.
			</summary>  
			<returns>Joints linear restitution.</returns>
		</member>
		<member name="M:Unigine.BodyParticles.setLinearStretch(float)">
			<summary>
			Sets the scale for the length of linear joints (relative the source mesh topology).
			</summary> 
			<param name="stretch"> Stretch scale for linear joints. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.BodyParticles.getLinearStretch const">
			<summary>
			Returns the current scale for the length of linear joints (relative the source mesh topology).
			</summary>  
			<returns>Stretch scale for linear joints.</returns>
		</member>
		<member name="M:Unigine.BodyParticles.setLinearThreshold(float)">
			<summary>
			Sets the threshold for linear stretching of the body's inner joints. When passing this threshold, the joints tear up.
			</summary> 
			<param name="threshold"> Linear stretching threshold. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.BodyParticles.getLinearThreshold const">
			<summary>
			Returns the current linear stretching of the body's inner joints. When passing this threshold, the joints tear up.
			</summary>  
			<returns>Joints linear stretching threshold.</returns>
		</member>
		<member name="M:Unigine.BodyParticles.setMass(float)">
			<summary>
			Sets a mass of the body.
			</summary> 
			<param name="mass"> Mass of the body. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.BodyParticles.getMass const">
			<summary>
			Returns the current mass of the body.
			</summary>  
			<returns>Mass of the body.</returns>
		</member>
		<member name="M:Unigine.BodyParticles.setNumIterations(int)">
			<summary>
			Sets the number of iterations used to solve inner joints between the particles. Note that if this value is too low, the precision of calculations will suffer.
			</summary> 
			<param name="iterations"> Number of iterations. If a non-positive value is provided, 1 will be used instead. </param> 
		</member>
		<member name="M:Unigine.BodyParticles.getNumIterations const">
			<summary>
			Returns the current number of iterations used to solve inner joints between particles.
			</summary>  
			<returns>Number of iterations.</returns>
		</member>
		<member name="M:Unigine.BodyParticles.getNumParticles const">
			<summary>
			Returns the total number of particles that constitute the body.
			</summary>  
			<returns>The number of particles.</returns>
		</member>
		<member name="M:Unigine.BodyParticles.setParticleMass(int,float)">
			<summary>
			Sets the mass for the specified particle.
			</summary> 
			<param name="num"> Particle number. </param>
			<param name="mass"> Particle mass. </param> 
		</member>
		<member name="M:Unigine.BodyParticles.getParticleMass(int) const">
			<summary>
			Returns the current mass of the specified particle.
			</summary> 
			<param name="num"> Particle number. </param> 
			<returns>Particle mass.</returns>
		</member>
		<member name="M:Unigine.BodyParticles.setParticlePosition(int,Unigine.Math.Vec3)">
			<summary>
			Sets the position of the specified body's particle.
			</summary> 
			<param name="num"> Particle number. </param>
			<param name="position"> Particle position in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyParticles.getParticlePosition(int) const">
			<summary>
			Returns the current position of the specified particle.
			</summary> 
			<param name="num"> Particle number. </param> 
			<returns>Particle position in world coordinates.</returns>
		</member>
		<member name="M:Unigine.BodyParticles.setParticleVelocity(int,Unigine.Math.vec3)">
			<summary>
			Sets the velocity of the specified particle.
			</summary> 
			<param name="num"> Particle number. </param>
			<param name="velocity"> Particle velocity. </param> 
		</member>
		<member name="M:Unigine.BodyParticles.getParticleVelocity(int) const">
			<summary>
			Returns the current velocity of the specified particle.
			</summary> 
			<param name="num"> Particle number. </param> 
			<returns>Particle velocity.</returns>
		</member>
		<member name="M:Unigine.BodyParticles.setRadius(float)">
			<summary>
			Sets the radius of the particles forming the body and represented as sphere shapes.
			</summary> 
			<param name="radius"> Radius of the sphere-shaped particles. </param> 
		</member>
		<member name="M:Unigine.BodyParticles.getRadius const">
			<summary>
			Returns the current radius of the particles forming the body and represented as sphere shapes.
			</summary>  
			<returns>Radius of the sphere-shaped particles.</returns>
		</member>
		<member name="M:Unigine.BodyParticles.setRestitution(float)">
			<summary>
			Sets the restitution of the body by bouncing.
			</summary> 
			<param name="restitution"> Body restitution. Provided value is saturated in range [0;1.0]. </param> 
		</member>
		<member name="M:Unigine.BodyParticles.getRestitution const">
			<summary>
			Returns the current restitution of the body by bouncing.
			</summary>  
			<returns>Body restitution.</returns>
		</member>
		<member name="M:Unigine.BodyParticles.setRigidity(float)">
			<summary>
			Sets rigidity of the body's inner joints movement, i.e. how much interpolated linear and angular velocities of all joints affect velocities of each separate joint.
			</summary> 
			<param name="rigidity"> Rigidity of joints interaction. Provided value is saturated in range [0;1.0]:By the value of 0, joints move independently.By the value of 1, joints move uniformly, as interpolated velocity greatly changes velocities of each joint. </param> 
		</member>
		<member name="M:Unigine.BodyParticles.getRigidity const">
			<summary>
			Returns the current rigidity of the body's inner joints movement, i.e. how much interpolated linear and angular velocities of all joints affect velocities of each separate joint.
			</summary>  
			<returns>Rigidity of joints movement:By the value of 0, joints move independently.By the value of 1, joints move uniformly, as interpolated velocity greatly changes velocities of each joint.</returns>
		</member>
		<member name="M:Unigine.BodyParticles.addParticleForce(int,Unigine.Math.vec3)">
			<summary>
			Applies a force to the given particle. Integrated forces are applied after calling the update.
			</summary> 
			<param name="num"> Particle number. </param>
			<param name="force"> Amount of force to apply. </param> 
		</member>
		<member name="M:Unigine.BodyParticles.addParticleImpulse(int,Unigine.Math.vec3)">
			<summary>
			Applies an impulse to the given particle. Impulses immediately affect particles velocities.
			</summary> 
			<param name="num"> Particle number. </param>
			<param name="impulse"> Amount of impulse to apply. </param> 
		</member>
		<member name="M:Unigine.BodyParticles.setIterationsMode(BodyParticles::ITERATIONS_MODE)">
			<summary>
			Sets iteration mode to be used for the particles body. The mode determines how the number of iterations for solving the constraints of the particles body is calculated. This method adds flexibility in fine-tuning of performance and simulation quality for each particles body.
			</summary> 
			<param name="mode"> Iteration mode to be used for the particles body:OVERRIDE - the resulting number of iterations is equal to the value set for the body.MULTIPLICATION - the resulting number of iterations is equal to the value set for the body multiplied by the global physics iterations number. </param> 
		</member>
		<member name="M:Unigine.BodyParticles.getIterationsMode const">
			<summary>
			Returns the current iteration mode to be used for the particles body. The mode determines how the number of iterations for solving the constraints of the particles body is calculated. This method adds flexibility in fine-tuning of performance and simulation quality for each particles body.
			</summary>  
			<returns>Current iteration mode of the particles body:OVERRIDE - the resulting number of iterations is equal to the value set for the body.MULTIPLICATION - the resulting number of iterations is equal to the value set for the body multiplied by the global physics iterations number.</returns>
		</member>
		<member name="F:Unigine.BodyParticles.ITERATIONS_MODE_MULTIPLICATION">
			<summary>
			In this mode the resulting number of iterations is equal to the value set for the body multiplied by the global physics iterations number.
		</summary>
		</member>
		<member name="F:Unigine.BodyParticles.ITERATIONS_MODE_OVERRIDE">
			<summary>
			In this mode the resulting number of iterations is equal to the Iterations value set for the body.
		</summary>
		</member>
		<member name="M:Unigine.BodyPath.#ctor">
			<summary>
			Constructor. Creates a path with default properties, along which a rigid body is moved.
			</summary>  
		</member>
		<member name="M:Unigine.BodyPath.#ctor(Unigine.Ptr{Unigine.Object})">
			<summary>
			Constructor. Creates a path with default properties for the given object. Along this path a rigid body is moved.
			</summary> 
			<param name="object"> Object represented with the new path body. </param> 
		</member>
		<member name="M:Unigine.BodyPath.getClosestPosition(Unigine.Math.Vec3)">
			<summary>
			Finds the point on the path which is the closest to the given reference point.
			</summary> 
			<param name="position"> Coordinates of the reference point. </param> 
			<returns>Coordinates of the reference point, if the path exists; otherwise, the (0 0 0) vector is returned.</returns>
		</member>
		<member name="M:Unigine.BodyPath.getClosestRotation(Unigine.Math.Vec3)">
			<summary>
			Finds the point on the path which is the closest to the given reference point and returns rotation set by the path in this point.
			</summary> 
			<param name="position"> Coordinates of the reference point. </param> 
			<returns>Rotation set by the path in the found point, if the path is exists; otherwise, the (0 0 0 1) quaternion is returned.</returns>
		</member>
		<member name="M:Unigine.BodyPath.getPath">
			<summary>
			Returns the path along which physical objects are moving. By using this function, you can change velocity of the objects moving along the path, their transformation, etc.
			</summary>  
			<returns>Instance of the Path class.</returns>
		</member>
		<member name="M:Unigine.BodyPath.setPathName(char,int)">
			<summary>
			Reloads the internal path transformation.
			</summary> 
			<param name="name"> Path to the path file to be set. </param>
			<param name="unique"> The dynamic flag:0 - If the reloaded path is changed at run time, paths loaded from the same file will be also changed.1 - If the reloaded path is changed at run time, paths loaded from the same file won't be changed. </param> 
		</member>
		<member name="M:Unigine.BodyPath.getPathName">
			<summary>
			Returns a name of the path along which physical objects are moving.
			</summary>  
			<returns>Path to the path file.</returns>
		</member>
		<member name="M:Unigine.BodyRagdoll.#ctor">
			<summary>
			Constructor. Creates a ragdoll with default properties.
			</summary>  
		</member>
		<member name="M:Unigine.BodyRagdoll.#ctor(Unigine.Ptr{Unigine.Object})">
			<summary>
			Constructor. Creates a ragdoll with default properties for a given object.
			</summary> 
			<param name="object"> Object approximated with the new ragdoll. </param> 
		</member>
		<member name="M:Unigine.BodyRagdoll.setBoneFrameBased(int,int)">
			<summary>
			Sets a value indicating if bone transformations should be based on skinned animation data or conditioned by physics.
			</summary> 
			<param name="bone"> Bone number. </param>
			<param name="based"> Positive value to set skinned animation-based transformations, 0 for ragdoll physical animation. </param> 
		</member>
		<member name="M:Unigine.BodyRagdoll.isBoneFrameBased(int)">
			<summary>
			Returns a value indicating if bone transformations are based on skinned animation data or conditioned by physics.
			</summary> 
			<param name="bone"> Bone number. </param> 
			<returns>Positive value if transformations are based on skinned animation, 0 if they are ragdoll physical animation.</returns>
		</member>
		<member name="M:Unigine.BodyRagdoll.getBoneName(int)">
			<summary>
			Returns the name of a given bone.
			</summary> 
			<param name="bone"> Bone number. </param> 
			<returns>Bone name.</returns>
		</member>
		<member name="M:Unigine.BodyRagdoll.getBoneNumber(int)">
			<summary>
			Checks whether the bone with the given number exists.
			</summary> 
			<param name="bone"> The number of the bone. </param> 
			<returns>Bone number.</returns>
		</member>
		<member name="M:Unigine.BodyRagdoll.setBones(Unigine.Ptr{Unigine.Node})">
			<summary>
			Imports a set of bones from a given node.
			</summary> 
			<param name="node"> Node, from which the bones will be imported. </param> 
		</member>
		<member name="M:Unigine.BodyRagdoll.getBones">
			<summary>
			Exports a set of bones into a given node.
			</summary>  
			<returns>Node, into which the bones will be exported.</returns>
		</member>
		<member name="M:Unigine.BodyRagdoll.updateBones">
			<summary>
			Updates transformations of all ragdoll bones.
			</summary>  
			<returns>true if transformations of all ragdoll bones were updated successfully; otherwise, false.</returns>
		</member>
		<member name="M:Unigine.BodyRagdoll.getBoneTransform(int)">
			<summary>
			Returns the transformation of animation bone for the current frame.
			</summary> 
			<param name="bone"> Bone number. </param> 
			<returns>Bone transformation matrix.</returns>
		</member>
		<member name="M:Unigine.BodyRagdoll.setFrameBased(int)">
			<summary>
			Sets a value indicating if ragdoll bones move according to the animation written in the file.
			</summary> 
			<param name="based"> true  to make the bones move according to the file animation, false to make the movements physics-driven. </param> 
		</member>
		<member name="M:Unigine.BodyRagdoll.isFrameBased">
			<summary>
			Returns a value indicating if ragdoll bones move according to the animation written in the file.
			</summary>  
			<returns>true if the bones move according to the file animation; otherwise, false.</returns>
		</member>
		<member name="M:Unigine.BodyRagdoll.setMass(float)">
			<summary>
			Sets a mass of the ragdoll.					If g (Earth's gravity) equals to 9.8 m/s						2, and 1 unit equals to 1 m, the mass is measured in kilograms.
			</summary> 
			<param name="mass"> Mass of the ragdoll. </param> 
		</member>
		<member name="M:Unigine.BodyRagdoll.getMass">
			<summary>
			Returns the mass of the ragdoll.					If g (Earth's gravity) equals to 9.8 m/s						2, and 1 unit equals to 1 m, the mass is measured in kilograms.
			</summary>  
			<returns>Mass of the ragdoll.</returns>
		</member>
		<member name="M:Unigine.BodyRagdoll.getNumBones">
			<summary>
			Returns the number of bones in the ragdoll.
			</summary>  
			<returns>Number of bones.</returns>
		</member>
		<member name="M:Unigine.BodyRagdoll.setRigidity(float)">
			<summary>
			Sets rigidity of bones movement, i.e. how much interpolated linear and angular velocities of all bones affect velocities of each separate bone.
			</summary> 
			<param name="rigidity"> Rigidity of bones movement. Provided value is saturated in range [0;1]:By the value of 0, bones are independent.By the value of 1, bones movement is uniform, as interpolated velocity greatly changes velocities of each bone. </param> 
		</member>
		<member name="M:Unigine.BodyRagdoll.getRigidity">
			<summary>
			Returns the rigidity of bones movement, i.e. how much interpolated linear and angular velocities of all bones affect velocities of each separate bone.
			</summary>  
			<returns>Rigidity of bones movement:By the value of 0, bones are independent.By the value of 1, bones movement is uniform, as interpolated velocity greatly changes velocities of each bone.</returns>
		</member>
		<member name="M:Unigine.BodyRagdoll.createBones(float,float,int)">
			<summary>
			Automatically generates a simplified skeleton from the mesh and its bones. Each bone is approximated with a convex hull or a capsule based on given parameters.
			</summary> 
			<param name="error"> Permissible error, which is used for creating convex hulls. This is an optional parameter. </param>
			<param name="threshold"> Threshold, which is used to detect and discard too small convex hulls. A convex hull, which volume is smaller than an average volume multiplied by the threshold, is discarded. This is an optional parameter. </param>
			<param name="capsule"> Approximation shape. By the value of 0, convex hull is used; the value of 1 sets capsule approximation. </param> 
			<returns>Created bone number.</returns>
		</member>
		<member name="M:Unigine.BodyRagdoll.findBone(char)">
			<summary>
			Searches for a bone with a given name.
			</summary> 
			<param name="name"> Name of the bone. </param> 
			<returns>Number of the bone in the list of bones, if it is found; otherwise, -1. </returns>
		</member>
		<member name="M:Unigine.BodyRigid.#ctor">
			<summary>
			Constructor. Creates a rigid body with default properties.
			</summary>  
		</member>
		<member name="M:Unigine.BodyRigid.#ctor(Unigine.Ptr{Unigine.Object})">
			<summary>
			Constructor. Creates a rigid body with default properties for a given object.
			</summary> 
			<param name="object"> Object approximated with the new rigid body. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.setAngularDamping(float)">
			<summary>
			Sets an angular damping of the body.
			</summary> 
			<param name="damping"> Angular damping. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.BodyRigid.getAngularDamping const">
			<summary>
			Returns the angular damping of the body.
			</summary>  
			<returns>Angular damping.</returns>
		</member>
		<member name="M:Unigine.BodyRigid.setAngularScale(Unigine.Math.vec3)">
			<summary>
			Sets a multiplier for the body's angular velocity per axis. If one of vec3 values is set to 0, movement along this axis will be restricted. For example, for 2D physics with movement restricted to a X axis, set the body's angular scale to (1,0,0).
			</summary> 
			<param name="scale"> Angular scale per axis, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.getAngularScale const">
			<summary>
			Returns a multiplier for the body's angular velocity per axis. If one of vec3 values is set to 0, movement along this axis will be restricted. For example, for 2D physics with movement restricted to a X axis, set the body's angular scale to (1,0,0).
			</summary>  
			<returns>Angular scale per axis.</returns>
		</member>
		<member name="M:Unigine.BodyRigid.setAngularVelocity(Unigine.Math.vec3)">
			<summary>
			Sets an angular velocity of the body.
			</summary> 
			<param name="velocity"> Angular velocity in radians per second, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.getAngularVelocity const">
			<summary>
			Returns the current angular velocity of the body.
			</summary>  
			<returns>Angular velocity in radians per second.</returns>
		</member>
		<member name="M:Unigine.BodyRigid.setCenterOfMass(Unigine.Math.vec3)">
			<summary>
			Sets coordinates of the center of mass of the body.
			</summary> 
			<param name="center"> Coordinates of the center of mass, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.getCenterOfMass const">
			<summary>
			Returns coordinates of the center of mass of the body.
			</summary>  
			<returns>Coordinates of the center of mass.</returns>
		</member>
		<member name="M:Unigine.BodyRigid.setFreezable(bool)">
			<summary>
			Sets a value indicating if the body should not be simulated if both its linear and angular velocities are below "freeze" ones (see setFrozenLinearVelocity and setFrozenAngularVelocity functions).
			</summary> 
			<param name="freezable"> Positive number to "freeze" the body when necessary; 0 for its physical state to be always updated. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.isFreezable const">
			<summary>
			Returns a value indicating if the object is not simulated if both its linear and angular velocities are below "freeze" ones (see setFrozenLinearVelocity and setFrozenAngularVelocity functions).
			</summary>  
			<returns>Positive number if the body "freezes" when necessary; 0 if its physical state is always updated.</returns>
		</member>
		<member name="M:Unigine.BodyRigid.setFrozenAngularVelocity(float)">
			<summary>
			Sets angular velocity threshold for freezing body simulation. If body angular velocity remains lower than this threshold during the number of Frozen frames (together with linear one), it stops to be updated.
			</summary> 
			<param name="velocity"> "Freeze" angular velocity. If the value is lower than the setFrozenAngularVelocity of the Physics class, it is overridden. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.getFrozenAngularVelocity const">
			<summary>
			Returns the current angular velocity threshold for freezing body simulation. If body angular velocity remains lower than this threshold during the number of Frozen frames (together with linear one), it stops to be updated.
			</summary>  
			<returns>"Freeze" angular velocity.</returns>
		</member>
		<member name="M:Unigine.BodyRigid.setFrozenLinearVelocity(float)">
			<summary>
			Sets linear velocity threshold for freezing body simulation. If body linear velocity remains lower than this threshold during the number of Frozen frames (together with angular one), it stops to be updated.
			</summary> 
			<param name="velocity"> "Freeze" linear velocity. If the value is lower than the setFrozenLinearVelocity of the Physics class, it is overridden. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.getFrozenLinearVelocity const">
			<summary>
			Returns the current linear velocity threshold for freezing body simulation. If body linear velocity remains lower than this threshold during the number of Frozen frames (together with angular one), it stops to be updated.
			</summary>  
			<returns>"Freeze" linear velocity.</returns>
		</member>
		<member name="M:Unigine.BodyRigid.getIMass const">
			<summary>
			Returns the inverse mass of the body.
			</summary>  
			<returns>Inverse mass of the body.</returns>
		</member>
		<member name="M:Unigine.BodyRigid.setInertia(Unigine.Math.mat3)">
			<summary>
			Sets an inertia tensor of the body. The inertia tensor describes the distribution of the mass over the body relative to the body's center of mass.
			</summary> 
			<param name="inertia"> Inertia tensor. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.getInertia const">
			<summary>
			Returns the inertia tensor of the body.
			</summary>  
			<returns>Inertia tensor.</returns>
		</member>
		<member name="M:Unigine.BodyRigid.getIWorldInertia const">
			<summary>
			Returns the inverse inertia tensor of the body, in the world coordinates.
			</summary>  
			<returns>Inverse inertia tensor of the body, in the world coordinates.</returns>
		</member>
		<member name="M:Unigine.BodyRigid.setLinearDamping(float)">
			<summary>
			Sets a linear damping of the body.
			</summary> 
			<param name="damping"> Linear damping. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.BodyRigid.getLinearDamping const">
			<summary>
			Returns the linear damping of the body.
			</summary>  
			<returns>Linear damping.</returns>
		</member>
		<member name="M:Unigine.BodyRigid.setLinearScale(Unigine.Math.vec3)">
			<summary>
			Sets a multiplier for the body's linear velocity per axis. If one of vec3 values is set to 0, movement along this axis will be restricted. For example, for 2D physics with movement restricted to a X axis, set the body's linear scale to (0,1,1).
			</summary> 
			<param name="scale"> Linear scale per axis. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.getLinearScale const">
			<summary>
			Returns a multiplier for the body's linear velocity per axis. If one of vec3 values is set to 0, movement along this axis will be restricted. For example, for 2D physics with movement restricted to a X axis, set the body's linear scale to (0,1,1).
			</summary>  
			<returns>Linear scale per axis.</returns>
		</member>
		<member name="M:Unigine.BodyRigid.setLinearVelocity(Unigine.Math.vec3)">
			<summary>
			Sets a linear velocity of the body.
			</summary> 
			<param name="velocity"> Linear velocity in units per second, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.getLinearVelocity const">
			<summary>
			Returns the current linear velocity of the body.
			</summary>  
			<returns>Linear velocity in units per second.</returns>
		</member>
		<member name="M:Unigine.BodyRigid.setMass(float)">
			<summary>
			Sets a mass of the body.					If g (Earth's gravity) equals to 9.8 m/s						2, and 1 unit equals to 1 m, the mass is measured in kilograms.
			</summary> 
			<param name="mass"> Mass of the body. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.getMass const">
			<summary>
			Returns the body mass.					If g (Earth's gravity) equals to 9.8 m/s						2, and 1 unit equals to 1 m, the mass is measured in kilograms.
			</summary>  
			<returns>Mass of the body.</returns>
		</member>
		<member name="M:Unigine.BodyRigid.setMaxAngularVelocity(float)">
			<summary>
			Sets a maximum angular velocity of the body.											This method sets the maximum angular velocity only when the updatePhysics() for the BodyRigid is called.
			</summary> 
			<param name="velocity"> Maximum angular velocity in radians per second. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.BodyRigid.getMaxAngularVelocity const">
			<summary>
			Returns the maximum angular velocity of the body.
			</summary>  
			<returns>Maximum angular velocity, per second.</returns>
		</member>
		<member name="M:Unigine.BodyRigid.setMaxLinearVelocity(float)">
			<summary>
			Sets a maximum linear velocity of the body.											This method sets the maximum linear velocity only when the updatePhysics() for the BodyRigid is called.
			</summary> 
			<param name="velocity"> Maximum linear velocity in units per second. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.BodyRigid.getMaxLinearVelocity const">
			<summary>
			Returns the maximum linear velocity of the body.
			</summary>  
			<returns>Maximum linear velocity in units per second.</returns>
		</member>
		<member name="M:Unigine.BodyRigid.setShapeBased(bool)">
			<summary>
			Sets a value indicating if mass and inertia of the body are bound to its shape properties or not.
			</summary> 
			<param name="based"> Positive number to bind mass and inertia of the body to its shape properties, 0 to allow arbitrary values.  </param> 
		</member>
		<member name="M:Unigine.BodyRigid.isShapeBased const">
			<summary>
			Returns a value indicating if mass and inertia of the body are bound to its shape properties or not.
			</summary>  
			<returns>Positive number if mass and inertia are calculated based on shape properties; otherwise, 0. </returns>
		</member>
		<member name="M:Unigine.BodyRigid.getVelocity(Unigine.Math.vec3) const">
			<summary>
			Returns the total linear velocity of the point determined by a given radius vector, specified in the local coordinates.
			</summary> 
			<param name="radius"> Radius vector starting in the body's center of mass. </param> 
			<returns>Total linear velocity in the given point of the body.</returns>
		</member>
		<member name="M:Unigine.BodyRigid.getWorldCenterOfMass const">
			<summary>
			Returns world coordinates of the center of mass of the body.
			</summary>  
			<returns>World coordinates of the body's center of mass.</returns>
		</member>
		<member name="M:Unigine.BodyRigid.getWorldVelocity(Unigine.Math.Vec3) const">
			<summary>
			Returns the total linear velocity of the point specified in world coordinates.
			</summary> 
			<param name="point"> Point of the body, in world coordinates. </param> 
			<returns>Total linear velocity in the given point.</returns>
		</member>
		<member name="M:Unigine.BodyRigid.addForce(Unigine.Math.vec3)">
			<summary>
								Applies a force to the center of mass of the body.					Unlike impulses, all forces are accumulated first, then the resulting force is calculated and applied to the body (during the physics simulation stage, when the body update() function is called).					You can call this function only from updatePhysics() function in the world script. Do not apply forces in the update() function, because you will get unstable result that varies each rendering frame.
			</summary> 
			<param name="force"> Force to be applied, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.addForce(Unigine.Math.vec3,Unigine.Math.vec3)">
			<summary>
								Applies a force to a point determined by a given radius vector, specified in the local coordinates. This function calculates the cross product of the radius vector and the force vector. It acts like a lever arm that changes both linear and angular velocities of the body.					Unlike impulses, all forces are accumulated first, then the resulting force is calculated and applied to the body (during the physics simulation stage, when the body update() function is called).					You can call this function only from updatePhysics() function in the world script. Do not apply forces in the update() function, because you will get unstable result that varies each rendering frame.
			</summary> 
			<param name="radius"> Radius vector, traced from the center of mass of the body to the point where the force is applied. </param>
			<param name="force"> Force to be applied, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.addImpulse(Unigine.Math.vec3,Unigine.Math.vec3)">
			<summary>
								Applies an impulse to a point determined by a given radius vector, specified in the local coordinates.					Unlike forces, impulses immediately affect both linear and angular velocities of the body.
			</summary> 
			<param name="radius"> Radius vector, traced from the center of mass to the point where the impulse is applied. </param>
			<param name="impulse"> Impulse to be applied, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.addLinearImpulse(Unigine.Math.vec3)">
			<summary>
			Applies an impulse similar to the addImpulse() method, but affects only the linear velocity.
			</summary> 
			<param name="impulse"> Impulse to be applied, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.addAngularImpulse(Unigine.Math.vec3)">
			<summary>
			Applies an impulse similar to the addImpulse() method, but affects only the angular velocity.
			</summary> 
			<param name="impulse"> Impulse to be applied, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.addTorque(Unigine.Math.vec3)">
			<summary>
								Applies a torque with a pivot point at the center of mass of the body, specified in the local coordinates.					All torque values are accumulated first, then the resulting torque is calculated and applied to the body (during the physics simulation stage, when the body update is called).					You can call this function only from updatePhysics() function in the world script. Do not apply forces in the update() function, because you will get unstable result that varies each rendering frame.
			</summary> 
			<param name="torque"> Torque to be applied, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.addTorque(Unigine.Math.vec3,Unigine.Math.vec3)">
			<summary>
								Applies a torque with a pivot point, determined by a given radius vector, specified in the local coordinates.					This function calculates the cross product of the radius vector and the force vector.					It acts like a lever arm that changes both angular and linear velocities of the body.					All torque values are accumulated first, then the resulting torque is calculated and applied to the body (during the physics simulation stage, when the body update is called).					You can call this function only from updatePhysics() function in the world script. Do not apply torques in the update() function, because you will get unstable result that varies each rendering frame.
			</summary> 
			<param name="radius"> Radius vector starting at the body's center of mass. Its end is the pivot point for the torque to be applied. </param>
			<param name="torque"> Torque to be applied, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.addWorldForce(Unigine.Math.Vec3,Unigine.Math.vec3)">
			<summary>
								Applies a force to a given point of the body that is specified in world coordinates. This function calculates the cross product of the radius vector (a vector from the center of mass to the point where force is applied) and the force vector. It acts like a lever arm that changes both linear and angular velocities of the body.					Unlike impulses, all forces are accumulated first, then the resulting force is calculated and applied to the body (during the physics simulation stage, when the body update is called).					You can call this function only from updatePhysics() function in the world script. Do not apply forces in the update() function, because you will get unstable result that varies each rendering frame.
			</summary> 
			<param name="point"> Point of the body, in world coordinates. </param>
			<param name="force"> Force to be applied, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.addWorldImpulse(Unigine.Math.Vec3,Unigine.Math.vec3)">
			<summary>
			Applies an impulse to a given point of the body, that is specified in world coordinates. Unlike forces, impulses immediately affect both linear and angular velocities of the body.
			</summary> 
			<param name="point"> Point of the body, in world coordinates. </param>
			<param name="impulse"> Impulse to be applied, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.addWorldTorque(Unigine.Math.Vec3,Unigine.Math.vec3)">
			<summary>
								Applies a torque with a pivot point at a given point of the body, that is specified in world coordinates. This function calculates the cross product of the radius vector (a vector from the center of mass to the pivot point) and the torque vector. It acts like a lever arm that changes both angular and linear velocities of the body.					All torque values are accumulated first, then the resulting torque is calculated and applied to the body (during the physics simulation stage, when the body update is called).					You can call this function only from updatePhysics() function in the world script. Do not apply torques in the update() function, because you will get unstable result that varies each rendering frame.
			</summary> 
			<param name="point"> Point of the body, in world coordinates. </param>
			<param name="torque"> Torque to be applied, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.createShapes(int,float,float)">
			<summary>
			Removes all previously created shapes and creates one or more convex shapes approximating the mesh.
			</summary> 
			<param name="depth"> Degree of decomposition of the mesh. If 0 or a negative value is provided, only one shape will be created. If a positive n is provided, the mesh will be decomposed n times. This is an optional parameter.  </param>
			<param name="error"> Approximation error, which is used to create convex hulls. This is an optional parameter. </param>
			<param name="threshold"> Threshold, which is used to decide, whether two adjoining convex shapes can be replaced with one larger shape. A pair of shapes is replaced with a larger shape, if their volumes are roughly the same. This value is clamped in the range [1 E-6; 1]. This is an optional parameter.  </param> 
			<returns>1 if the convex shapes are created successfully; otherwise 0.</returns>
		</member>
		<member name="M:Unigine.BodyRigid.setHighPriorityContacts(bool)">
			<summary>
			Sets a value indicating if the body has the priority of handling detected contacts it participates in. A contact can be handled by any of the bodies that participate in it. To which body a contact is assigned is random. If the contact is assigned to and handled by the body it is called an internal one, otherwise it is called external (handled by another body). Iterating through internal contacts is much faster than through external ones, so this method can be used if you want a certain body to handle most of the contacts it participates in (i.e., have them as internal) to gain some performance.A contact between two bodies with high priority shall be handled by one of them determined at random.
			</summary> 
			<param name="contacts"> true to set high priority of handling detected contacts for the body; otherwise false. </param> 
		</member>
		<member name="M:Unigine.BodyRigid.isHighPriorityContacts const">
			<summary>
			Returns a value indicating if the body has the priority of handling detected contacts it participates in. A contact can be handled by any of the bodies that participate in it. To which body a contact is assigned is random. If the contact is assigned to and handled by the body it is called an internal one, otherwise it is called external (handled by another body). Iterating through internal contacts is much faster than through external ones, so this method can be used if you want a certain body to handle most of the contacts it participates in (i.e., have them as internal) to gain some performance.A contact between two bodies with high priority shall be handled by one of them determined at random.
			</summary>  
			<returns>true if the body has the priority of handling detected contacts it participates in; otherwise false.</returns>
		</member>
		<member name="M:Unigine.BodyRope.#ctor">
			<summary>
			Constructor. Creates a rope body with default properties.
			</summary>  
		</member>
		<member name="M:Unigine.BodyRope.#ctor(Unigine.Ptr{Unigine.Object})">
			<summary>
			Constructor. Creates a rope body with default properties for a given object.
			</summary> 
			<param name="object"> Object represented with the new rope body. </param> 
		</member>
		<member name="M:Unigine.BodyWater.#ctor">
			<summary>
			Constructor. Creates a water body with default properties.
			</summary>  
		</member>
		<member name="M:Unigine.BodyWater.#ctor(Unigine.Ptr{Unigine.Object})">
			<summary>
			Constructor. Creates a  water body with default properties for a given object.
			</summary> 
			<param name="object"> Object with a new water body. </param> 
		</member>
		<member name="M:Unigine.BodyWater.setAbsorption(int)">
			<summary>
			Updates a value indicating if the waves should be dispersed along the mesh perimeter.
			</summary> 
			<param name="absorption"> Positive number to allow wave dispersion, 0 for the waves to be reflected. </param> 
		</member>
		<member name="M:Unigine.BodyWater.getAbsorption">
			<summary>
			Returns a value indicating if the waves are dispersed along the mesh perimeter.
			</summary>  
			<returns>Positive value, if the waves are dispersed along the mesh perimeter; 0 if they are reflected.</returns>
		</member>
		<member name="M:Unigine.BodyWater.setAngularDamping(float)">
			<summary>
			Updates a value indicating how much the angular velocity of the objects decreases when they get into the water.
			</summary> 
			<param name="damping"> Anglular damping value. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.BodyWater.getAngularDamping">
			<summary>
			Returns the current value indicating how much the angular velocity of the objects decreases when they get into the water.
			</summary>  
			<returns>Anglular damping value.</returns>
		</member>
		<member name="M:Unigine.BodyWater.setDensity(float)">
			<summary>
			Updates the density of the water that determines objects buoyancy.
			</summary> 
			<param name="density"> Density value. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.BodyWater.getDensity">
			<summary>
			Returns the current density of the water that determines objects buoyancy.
			</summary>  
			<returns>Density value.</returns>
		</member>
		<member name="M:Unigine.BodyWater.setDepth(float)">
			<summary>
			Updates the depth of the water (unless intersection has occurred).
			</summary> 
			<param name="depth"> Depth value. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.BodyWater.getDepth">
			<summary>
			Returns the current depth of the water (unless intersection has occurred).
			</summary>  
			<returns>Depth value.</returns>
		</member>
		<member name="M:Unigine.BodyWater.setDistance(float)">
			<summary>
			Updates the distance of water simulation. It does not interfere with objects buoyancy.
			</summary> 
			<param name="distance"> Simulation distance. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.BodyWater.getDistance">
			<summary>
			Returns the current distance of water simulation. It does not interfere with objects buoyancy.
			</summary>  
			<returns>Simulation distance.</returns>
		</member>
		<member name="M:Unigine.BodyWater.setInteractionForce(float)">
			<summary>
			Updates the interaction force that determines how much velocity values of water and objects that get into it are leveled.
			</summary> 
			<param name="force"> Interaction force value. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.BodyWater.getInteractionForce">
			<summary>
			Returns the current interaction force that determines how much velocity values of water and objects that get into it are leveled.
			</summary>  
			<returns>Interaction force value.</returns>
		</member>
		<member name="M:Unigine.BodyWater.setIntersection(int)">
			<summary>
			Updates a value indicating if intersection with the ground is enabled. The ground should be a parent node.
			</summary> 
			<param name="intersection"> Positive value to enable intersection, 0 to disable it. </param> 
		</member>
		<member name="M:Unigine.BodyWater.getIntersection">
			<summary>
			Returns a value indicating if intersection with the ground is enabled. The ground should be a parent node.
			</summary>  
			<returns>Positive value if intersection is enabled, 0 if disabled.</returns>
		</member>
		<member name="M:Unigine.BodyWater.setLinearDamping(float)">
			<summary>
			Updates a value indicating how much the linear velocity of the objects decreases when they get into the water.
			</summary> 
			<param name="damping"> Linear damping value. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.BodyWater.getLinearDamping">
			<summary>
			Returns the current value indicating how much the linear velocity of the objects decreases when they get into the water.
			</summary>  
			<returns>Linear damping value.</returns>
		</member>
		<member name="M:Unigine.BodyWater.setLiquidity(float)">
			<summary>
			Updates the viscosity of the water.
			</summary> 
			<param name="liquidity"> Liquidity value. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.BodyWater.getLiquidity">
			<summary>
			Returns the current fluidity of the water.
			</summary>  
			<returns>Liquidity value.</returns>
		</member>
		<member name="M:Unigine.BodyWater.getParticleHeight(Unigine.Math.vec3)">
			<summary>
			Returns the vertical shift of the given point of the water.
			</summary> 
			<param name="position"> Point local coordinates (only along X and Y axes). </param> 
			<returns>Height in units of the vertical water shift.</returns>
		</member>
		<member name="M:Unigine.BodyWater.getParticleVelocity(Unigine.Math.vec3)">
			<summary>
			Returns the velocity value in the given point of the water.
			</summary> 
			<param name="position"> Point local coordinates (only along X and Y axes). </param> 
			<returns>Velocity value.</returns>
		</member>
		<member name="M:Unigine.BodyWater.addParticleHeight(Unigine.Math.vec3,float)">
			<summary>
			Adds the vertical shift to the water. Nearby water particles, that form a plane water grid, will change their height accordingly, simulating rings on the water.
			</summary> 
			<param name="position"> Point local coordinates (only along X and Y axes) of the vertical shift. </param>
			<param name="height"> Height in units of the vertical water shift. </param> 
		</member>
		<member name="M:Unigine.BodyWater.addParticleVelocity(Unigine.Math.vec3,Unigine.Math.vec3)">
			<summary>
			Applies the force to the water. To nearby water particles, that form a plane water grid, will be passed appropriate velocity values, simulating wake from the moving object.
			</summary> 
			<param name="position"> Point local coordinates (only along X and Y axes) of applying the force. </param>
			<param name="velocity"> Velocity value. </param> 
		</member>
		<member name="M:Unigine.Joint.createJoint(int)">
			<summary>
			Creates a new joint of the specified type.
			</summary> 
			<param name="type"> Joint type. One of the JOINT_* values. </param> 
			<returns>New created joint smart pointer.</returns>
		</member>
		<member name="M:Unigine.Joint.createJoint(char)">
			<summary>
			Creates a new joint of the specified type.
			</summary> 
			<param name="type_name"> Joint type name. </param> 
			<returns>New created joint smart pointer.</returns>
		</member>
		<member name="M:Unigine.Joint.setAnchor0(Unigine.Math.Vec3)">
			<summary>
			Sets coordinates of the anchor point in a system of coordinates of the first connected body.
			</summary> 
			<param name="anchor"> Coordinates of the anchor point in the body coordinate space. </param> 
		</member>
		<member name="M:Unigine.Joint.getAnchor0 const">
			<summary>
			Returns the coordinates of the anchor point in a system of coordinates of the first connected body.
			</summary>  
			<returns>Coordinates of the anchor point in the body coordinate space.</returns>
		</member>
		<member name="M:Unigine.Joint.setAnchor1(Unigine.Math.Vec3)">
			<summary>
			Sets coordinates of the anchor point in a system of coordinates of the second connected body.
			</summary> 
			<param name="anchor"> Coordinates of the anchor point in the body coordinate space. </param> 
		</member>
		<member name="M:Unigine.Joint.getAnchor1 const">
			<summary>
			Returns the coordinates of the anchor point in a system of coordinates of the second connected body.
			</summary>  
			<returns>Coordinates of the anchor point in the body coordinate space.</returns>
		</member>
		<member name="M:Unigine.Joint.setAngularRestitution(float)">
			<summary>
			Sets the current angular restitution (stiffness) of the joint. Angular restitution defines how fast the joint compensates for change of the angle between two bodies. When bodies are turned relative each other, restitution controls the magnitude of force which is applied to both bodies so that their anchor points to become aligned again. For example:											1 means that the joint is to return bodies in place throughout 1 physics tick.						0.2 means that the joint is to return bodies in place throughout 5 physics ticks.					The maximum value of					1 can lead to destabilization of physics (as too great forces are applied).
			</summary> 
			<param name="restitution"> Angular restitution. The provided value will be clamped in the range [0;1]. </param> 
		</member>
		<member name="M:Unigine.Joint.getAngularRestitution const">
			<summary>
			Returns the current angular restitution (stiffness) of the joint. Angular restitution defines how fast the joint compensates for change of the angle between two bodies. When bodies are turned relative each other, restitution controls the magnitude of force which is applied to both bodies so that their anchor points to become aligned again. For example:											1 means that the joint is to return bodies in place throughout 1 physics tick.						0.2 means that the joint is to return bodies in place throughout 5 physics ticks.					The maximum value of					1 can lead to destabilization of physics (as too great forces are applied).
			</summary>  
			<returns>Angular restitution in the range [0;1].</returns>
		</member>
		<member name="M:Unigine.Joint.setAngularSoftness(float)">
			<summary>
			Sets the angular softness (elasticity) of the joint. When the joint is twisted, angular softness defines whether angular velocities of the bodies are averaged out. For example:											0 means that the joint is rigid. Angular velocities of the first and the second body are independent.						1 means that the joint is elastic (jelly-like). If the first body changes its velocity, velocity of the second body is equalized with it.
			</summary> 
			<param name="softness"> Angular softness. The provided value will be clamped in the range [0;1]. </param> 
		</member>
		<member name="M:Unigine.Joint.getAngularSoftness const">
			<summary>
			Returns the current angular softness (elasticity) of the joint. When the joint is twisted, angular softness defines whether angular velocities of the bodies are averaged out. For example:											0 means that the joint is rigid. Angular velocities of the first and the second body are independent.						1 means that the joint is elastic (jelly-like). If the first body changes its velocity, velocity of the second body is equalized with it.
			</summary>  
			<returns>Angular softness in the range [0;1].</returns>
		</member>
		<member name="M:Unigine.Joint.setNode0(Unigine.Ptr{Unigine.Node})">
			<summary>
			Sets the node possessing the first body to be connected to the joint.
			</summary> 
			<param name="node0"> Node possessing the first body connected to the joint is assigned. The node must be an object and must have a body assigned. </param> 
		</member>
		<member name="M:Unigine.Joint.getNode0 const">
			<summary>
			Returns a node possessing the first body connected to the joint.
			</summary>  
			<returns>Node possessing the first body connected to the joint is assigned (if it exists).</returns>
		</member>
		<member name="M:Unigine.Joint.setNode1(Unigine.Ptr{Unigine.Node})">
			<summary>
			Sets the node possessing the second body to be connected to the joint.
			</summary> 
			<param name="node1"> Node possessing the second body connected to the joint is assigned. The node must be an object and must have a body assigned. </param> 
		</member>
		<member name="M:Unigine.Joint.getNode1 const">
			<summary>
			Returns a node possessing the second body connected to the joint.
			</summary>  
			<returns>Node possessing the second body connected to the joint is assigned (if it exists).</returns>
		</member>
		<member name="M:Unigine.Joint.setBody0(Unigine.Ptr{Unigine.Body})">
			<summary>
			Sets the first body connected using the joint.
			</summary> 
			<param name="body"> The first body connected with the joint. </param> 
		</member>
		<member name="M:Unigine.Joint.getBody0 const">
			<summary>
			Returns the first body connected using the joint.
			</summary>  
			<returns>The first body connected with the joint.</returns>
		</member>
		<member name="M:Unigine.Joint.setBody1(Unigine.Ptr{Unigine.Body})">
			<summary>
			Sets the second body connected using the joint.
			</summary> 
			<param name="body"> The second body connected with the joint. </param> 
		</member>
		<member name="M:Unigine.Joint.getBody1 const">
			<summary>
			Returns the second body connected using the joint.
			</summary>  
			<returns>The second body connected with the joint.</returns>
		</member>
		<member name="M:Unigine.Joint.getBodyRigid0">
			<summary>
			Returns the first connected body as a rigid body.
			</summary>  
			<returns>The first rigid body connected using the joint or NULL (0), if the body is not rigid. </returns>
		</member>
		<member name="M:Unigine.Joint.getBodyRigid1">
			<summary>
			Returns the second connected body as a rigid body.
			</summary>  
			<returns>The second rigid body connected using the joint or NULL (0), if the body is not rigid. </returns>
		</member>
		<member name="M:Unigine.Joint.setBroken(bool)">
			<summary>
			Sets a value indicating if the joint is broken or not.
			</summary> 
			<param name="broken"> Positive number to break the joint, 0 to make it intact.  </param> 
		</member>
		<member name="M:Unigine.Joint.isBroken const">
			<summary>
			Returns a value indicating if the joint is broken or not.
			</summary>  
			<returns>Positive number if the joint is broken; otherwise, 0. </returns>
		</member>
		<member name="M:Unigine.Joint.addBrokenCallback(Unigine.CallbackBase1{Unigine.Ptr{Unigine.Joint}})">
			<summary>
			Adds a callback function to be called when the joint breaks. The signature of the broken callback function must be as follows:					You can set a callback function as follows:										Example: Setting a joint broken callback function for a certain class:
			</summary> 
			<param name="func"> Callback pointer. </param> 
			<returns>ID of the last added broken callback, if the callback was added successfully; otherwise, nullptr. This ID can be used to remove this callback when necessary.</returns>
		</member>
		<member name="M:Unigine.Joint.removeBrokenCallback(void)">
			<summary>
			Removes the specified callback from the list of broken callbacks.
			</summary> 
			<param name="id"> Broken callback ID obtained when adding it. </param> 
			<returns>True if the broken callback with the given ID was removed successfully; otherwise false.</returns>
		</member>
		<member name="M:Unigine.Joint.clearBrokenCallbacks">
			<summary>
			Clears all added broken callbacks.
			</summary>  
		</member>
		<member name="M:Unigine.Joint.setCollision(int)">
			<summary>
			Sets a value indicating if collisions between the connected bodies are enabled.
			</summary> 
			<param name="c"> Positive number to enable collisions between the bodies, 0 to disable them.  </param> 
		</member>
		<member name="M:Unigine.Joint.getCollision const">
			<summary>
			Returns a value indicating if collisions between the connected bodies are enabled.
			</summary>  
			<returns>Positive number if collisions between the bodies are enabled; otherwise, 0. </returns>
		</member>
		<member name="M:Unigine.Joint.setEnabled(bool)">
			<summary>
			Enables or disables joint calculations.
			</summary> 
			<param name="enable"> Positive number to enable the joint, 0 to disable it.  </param> 
		</member>
		<member name="M:Unigine.Joint.isEnabled const">
			<summary>
			Returns a value indicating if the joint calculations are enabled.
			</summary>  
			<returns>1 if the joint is enabled; otherwise, 0. </returns>
		</member>
		<member name="M:Unigine.Joint.isEnabledSelf const">
			<summary>
			Returns a value indicating is the joint is enabled.
			</summary>  
			<returns>1 if the joint is enabled; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Joint.setFrozen(bool)">
			<summary>
			Freezes or unfreezes the joint.
			</summary> 
			<param name="f"> Positive number to freeze the joint, 0 to unfreeze it.  </param> 
		</member>
		<member name="M:Unigine.Joint.isFrozen const">
			<summary>
			Returns a value indicating if the joint is frozen or not.
			</summary>  
			<returns>Positive number if the joint is frozen; otherwise, 0. </returns>
		</member>
		<member name="M:Unigine.Joint.setID(int)">
			<summary>
			Sets the unique ID for the joint.
			</summary> 
			<param name="id"> Unique ID. </param> 
			<returns>1 if the ID is set successfully; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Joint.getID const">
			<summary>
			Returns the unique ID of the joint.
			</summary>  
			<returns>Unique ID.</returns>
		</member>
		<member name="M:Unigine.Joint.setLinearRestitution(float)">
			<summary>
			Sets the linear restitution (stiffness) of the joint. Linear restitution defines how fast the joint compensates for linear coordinate change between two bodies. When bodies are dragged apart, restitution controls the magnitude of force which is applied to both bodies so that their anchor points to become aligned again. For example:											1 means that the joint is to return bodies in place throughout 1 physics tick.						0.2 means that the joint is to return bodies in place throughout 5 physics ticks.					The maximum value of					1 can lead to destabilization of physics (as too great forces are applied).
			</summary> 
			<param name="restitution"> Linear restitution. The provided value will be clamped in the range [0;1]. </param> 
		</member>
		<member name="M:Unigine.Joint.getLinearRestitution const">
			<summary>
			Returns the current linear restitution (stiffness) of the joint. Linear restitution defines how fast the joint compensates for linear coordinate change between two bodies. When bodies are dragged apart, restitution controls the magnitude of force which is applied to both bodies so that their anchor points to become aligned again. For example:											1 means that the joint is to return bodies in place throughout 1 physics tick.						0.2 means that the joint is to return bodies in place throughout 5 physics ticks.					The maximum value of					1 can lead to destabilization of physics (as too great forces are applied).
			</summary>  
			<returns>Linear restitution in the range [0;1].</returns>
		</member>
		<member name="M:Unigine.Joint.setLinearSoftness(float)">
			<summary>
			Sets the linear softness (elasticity) of the joint. When the joint is stretched, linear softness defines whether linear velocities of the bodies are averaged out. For example:											0 means that the joint is rigid. Linear velocities of the first and the second body are independent.						1 means that the joint is elastic (jelly-like). If the first body changes its velocity, velocity of the second body is equalized with it.
			</summary> 
			<param name="softness"> Linear softness. The provided value will be clamped in the range [0;1]. </param> 
		</member>
		<member name="M:Unigine.Joint.getLinearSoftness const">
			<summary>
			Returns the current linear softness (elasticity) of the joint. When the joint is stretched, linear softness defines whether linear velocities of the bodies are averaged out. For example:											0 means that the joint is rigid. Velocities of the first and the second body are independent.						1 means that the joint is elastic (jelly-like). If the first body changes its velocity, velocity of the second body is equalized with it.
			</summary>  
			<returns>Linear softness value in the range [0;1].</returns>
		</member>
		<member name="M:Unigine.Joint.setMaxForce(float)">
			<summary>
			Sets the maximum amount of force that can be exerted on the joint. If this limit is exceeded, the joint breaks.
			</summary> 
			<param name="force"> Maximum amount of force. </param> 
		</member>
		<member name="M:Unigine.Joint.getMaxForce const">
			<summary>
			Returns the maximum amount of force that can be exerted on the joint. If this limit is exceeded, the joint breaks.
			</summary>  
			<returns>Maximum amount of force.</returns>
		</member>
		<member name="M:Unigine.Joint.setMaxTorque(float)">
			<summary>
			Sets the maximum amount of torque that can be exerted on the joint. If this limit is exceeded, the joint breaks.
			</summary> 
			<param name="torque"> Maximum amount of torque. </param> 
		</member>
		<member name="M:Unigine.Joint.getMaxTorque const">
			<summary>
			Returns the maximum amount of torque that can be exerted on the joint. If this limit is exceeded, the joint breaks.
			</summary>  
			<returns>Maximum amount of torque.</returns>
		</member>
		<member name="M:Unigine.Joint.setName(char)">
			<summary>
			Sets the name of the joint.
			</summary> 
			<param name="name"> Name of the joint. </param> 
		</member>
		<member name="M:Unigine.Joint.getName const">
			<summary>
			Returns the name of the joint.
			</summary>  
			<returns>Name of the joint.</returns>
		</member>
		<member name="M:Unigine.Joint.setNumIterations(int)">
			<summary>
			Sets the number of iterations used to solve joints. Note that if this value is too low, the precision of calculations will suffer.
			</summary> 
			<param name="num_iterations"> Number of iterations. If a non-positive value is provided, 1 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.Joint.getNumIterations const">
			<summary>
			Returns the current number of iterations used to solve joints.
			</summary>  
			<returns>Number of iterations.</returns>
		</member>
		<member name="M:Unigine.Joint.getType const">
			<summary>
			Returns the type of the joint.
			</summary>  
			<returns>One of the JOINT_* pre-defined variables. </returns>
		</member>
		<member name="M:Unigine.Joint.getTypeName const">
			<summary>
			Returns the name of the joint type.
			</summary>  
			<returns>Type name.</returns>
		</member>
		<member name="M:Unigine.Joint.getTypeName(int)">
			<summary>
			Returns the name of a joint type with a given ID.
			</summary> 
			<param name="type"> Joint type ID. One of the JOINT_* values. </param> 
			<returns>Joint type name.</returns>
		</member>
		<member name="M:Unigine.Joint.setWorldAnchor(Unigine.Math.Vec3)">
			<summary>
			Sets the anchor point in the world coordinates.
			</summary> 
			<param name="anchor"> Coordinates of the anchor point in the world space. </param> 
		</member>
		<member name="M:Unigine.Joint.getWorldAnchor const">
			<summary>
			Returns the anchor point in the world coordinates.
			</summary>  
			<returns>Coordinates of the anchor point in the world space.</returns>
		</member>
		<member name="M:Unigine.Joint.clone const">
			<summary>
			Clones the joint.
			</summary>  
			<returns>Copy of the joint.</returns>
		</member>
		<member name="M:Unigine.Joint.renderVisualizer(Unigine.Math.vec4)">
			<summary>
			Renders the joint.					You should enable the engine visualizer by the show_visualizer 1 console command.
			</summary> 
			<param name="color"> Color, in which the joint will be rendered. </param> 
		</member>
		<member name="M:Unigine.Joint.saveState(Unigine.Ptr{Unigine.Stream}) const">
			<summary>
			Saves the state of a given node into a binary stream.											If a node is a parent for other nodes, states of these child nodes need to be saved manually.						To save the state from a buffer, file or a message from a socket, make sure the stream is opened. For buffers and files, you also need to set the proper position for reading.										Example using saveState() and restoreState() methods:
			</summary> 
			<param name="stream"> Stream to save node state data. </param> 
			<returns>true if the node state is saved successfully; otherwise, false.</returns>
		</member>
		<member name="M:Unigine.Joint.restoreState(Unigine.Ptr{Unigine.Stream})">
			<summary>
			Restores the state of a given node from a binary stream.											If a node is a parent for other nodes, states of these child nodes need to be restored manually.						To save the state into a buffer, file or a message from a socket, make sure the stream is opened. If necessary, you can set a position for writing for buffers and files.										Example using saveState() and restoreState() methods:
			</summary> 
			<param name="stream"> Stream with saved node state data. </param> 
			<returns>true if the node state is restored successfully; otherwise, false.</returns>
		</member>
		<member name="M:Unigine.Joint.swap(Unigine.Ptr{Unigine.Joint})">
			<summary>
			Swaps the joints saving the pointers.
			</summary> 
			<param name="joint"> A joint to swap. </param> 
		</member>
		<member name="F:Unigine.Joint.JOINT_BALL">
			<summary>
			Ball joint.
		</summary>
		</member>
		<member name="F:Unigine.Joint.JOINT_CYLINDRICAL">
			<summary>
			Cylindrical joint.
		</summary>
		</member>
		<member name="F:Unigine.Joint.JOINT_FIXED">
			<summary>
			Fixed joint.
		</summary>
		</member>
		<member name="F:Unigine.Joint.JOINT_HINGE">
			<summary>
			Hinge joint.
		</summary>
		</member>
		<member name="F:Unigine.Joint.JOINT_PARTICLES">
			<summary>
			Particles joint.
		</summary>
		</member>
		<member name="F:Unigine.Joint.JOINT_PATH">
			<summary>
			Path joint.
		</summary>
		</member>
		<member name="F:Unigine.Joint.JOINT_PRISMATIC">
			<summary>
			Prismatic joint.
		</summary>
		</member>
		<member name="F:Unigine.Joint.JOINT_SUSPENSION">
			<summary>
			Suspension joint.
		</summary>
		</member>
		<member name="F:Unigine.Joint.JOINT_WHEEL">
			<summary>
			Wheel joint.
		</summary>
		</member>
		<member name="F:Unigine.Joint.NUM_JOINTS">
			<summary>
			Number of joints.
		</summary>
		</member>
		<member name="M:Unigine.JointBall.#ctor">
			<summary>
			Constructor. Creates a ball joint with an anchor at the origin of the world coordinates.
			</summary>  
		</member>
		<member name="M:Unigine.JointBall.#ctor(Unigine.Ptr{Unigine.Body},Unigine.Ptr{Unigine.Body})">
			<summary>
			Constructor. Creates a ball joint connecting two given bodies. An anchor is placed between centers of mass of the bodies.
			</summary> 
			<param name="body0"> First body to be connected with the joint. </param>
			<param name="body1"> Second body to be connected with the joint. </param> 
		</member>
		<member name="M:Unigine.JointBall.#ctor(Unigine.Ptr{Unigine.Body},Unigine.Ptr{Unigine.Body},Unigine.Math.Vec3)">
			<summary>
			Constructor. Creates a ball joint connecting two given bodies with an anchor placed at specified coordinates.
			</summary> 
			<param name="body0"> First body to be connected with the joint. </param>
			<param name="body1"> Second body to be connected with the joint. </param>
			<param name="anchor"> Anchor coordinates. </param> 
		</member>
		<member name="M:Unigine.JointBall.#ctor(Unigine.Ptr{Unigine.Body},Unigine.Ptr{Unigine.Body},Unigine.Math.Vec3,Unigine.Math.vec3)">
			<summary>
			Constructor. Creates a ball joint connecting two given bodies with specified axis coordinates and an anchor placed at specified coordinates.
			</summary> 
			<param name="body0"> First body to be connected with the joint. </param>
			<param name="body1"> Second body to be connected with the joint. </param>
			<param name="anchor"> Anchor coordinates. </param>
			<param name="axis"> Axis coordinates. </param> 
		</member>
		<member name="M:Unigine.JointBall.setAngularDamping(float)">
			<summary>
			Sets an angular damping of the joint.
			</summary> 
			<param name="damping"> Angular damping. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.JointBall.getAngularDamping">
			<summary>
			Returns the angular damping of the joint.
			</summary>  
			<returns>Angular damping.</returns>
		</member>
		<member name="M:Unigine.JointBall.setAngularLimitAngle(float)">
			<summary>
			Sets a swing limit angle. Swing limit specifies how much connected bodies can bend from the joint axis.
			</summary> 
			<param name="angle"> Angle in degrees. The provided value will be saturated in the range [0; 180]. 0 means no limit.  </param> 
		</member>
		<member name="M:Unigine.JointBall.getAngularLimitAngle">
			<summary>
			Returns the swing limit angle. Swing limit specifies how much connected bodies can bend from the joint axis. 0 means there is no limit.
			</summary>  
			<returns>Swing limit angle in degrees.</returns>
		</member>
		<member name="M:Unigine.JointBall.setAngularLimitFrom(float)">
			<summary>
			Sets a low twist limit angle. Twist limit specifies how much a connected body can twist around the joint axis.
			</summary> 
			<param name="from"> Angle in degrees. The provided value will be saturated in the range [-180; 180].  </param> 
		</member>
		<member name="M:Unigine.JointBall.getAngularLimitFrom">
			<summary>
			Returns the low twist limit angle. Twist limit specifies how much a connected body can twist around the joint axis.
			</summary>  
			<returns>Low twist limit angle in degrees.</returns>
		</member>
		<member name="M:Unigine.JointBall.setAngularLimitTo(float)">
			<summary>
			Sets a high twist limit angle. Twist limit specifies how much a connected body can twist around the joint axis.
			</summary> 
			<param name="to"> Angle in degrees. The provided value will be saturated in the range [-180; 180].  </param> 
		</member>
		<member name="M:Unigine.JointBall.getAngularLimitTo">
			<summary>
			Returns the high twist limit angle. Twist limit specifies how much a connected body can twist around the joint axis.
			</summary>  
			<returns>High twist limit angle in degrees.</returns>
		</member>
		<member name="M:Unigine.JointBall.setAxis0(Unigine.Math.vec3)">
			<summary>
			Sets an axis of the first connected body.
			</summary> 
			<param name="axis0"> Axis of the first body. The provided vector will be normalized. </param> 
		</member>
		<member name="M:Unigine.JointBall.getAxis0">
			<summary>
			Returns the axis of the first connected body.
			</summary>  
			<returns>Axis of the first body.</returns>
		</member>
		<member name="M:Unigine.JointBall.setAxis1(Unigine.Math.vec3)">
			<summary>
			Sets an axis of the second connected body.
			</summary> 
			<param name="axis1"> Axis of the second body. The provided vector will be normalized. </param> 
		</member>
		<member name="M:Unigine.JointBall.getAxis1">
			<summary>
			Returns the axis of the second connected body.
			</summary>  
			<returns>Axis of the second body.</returns>
		</member>
		<member name="M:Unigine.JointBall.setWorldAxis(Unigine.Math.vec3)">
			<summary>
			Sets a joint axis. This method updates axes of the connected bodies.
			</summary> 
			<param name="axis"> Joint axis. </param> 
		</member>
		<member name="M:Unigine.JointBall.getWorldAxis">
			<summary>
			Returns the joint axis. The joint axis is calculated based on the axes of the connected bodies.
			</summary>  
			<returns>Joint axis.</returns>
		</member>
		<member name="M:Unigine.JointCylindrical.#ctor">
			<summary>
			Constructor. Creates a cylindrical joint with an anchor at the origin of the world coordinates.
			</summary>  
		</member>
		<member name="M:Unigine.JointCylindrical.#ctor(Unigine.Ptr{Unigine.Body},Unigine.Ptr{Unigine.Body})">
			<summary>
			Constructor. Creates a cylindrical joint connecting two given bodies. An anchor is placed between centers of mass of the bodies.
			</summary> 
			<param name="body0"> First body to be connected with the joint. </param>
			<param name="body1"> Second body to be connected with the joint. </param> 
		</member>
		<member name="M:Unigine.JointCylindrical.#ctor(Unigine.Ptr{Unigine.Body},Unigine.Ptr{Unigine.Body},Unigine.Math.Vec3,Unigine.Math.vec3)">
			<summary>
			Constructor. Creates a cylindrical joint connecting two given bodies with specified axis coordinates and an anchor placed at specified coordinates.
			</summary> 
			<param name="body0"> First body to be connected with the joint. </param>
			<param name="body1"> Second body to be connected with the joint. </param>
			<param name="anchor"> Anchor coordinates. </param>
			<param name="axis"> Axis coordinates. </param> 
		</member>
		<member name="M:Unigine.JointCylindrical.setAngularAngle(float)">
			<summary>
			Sets a target angle of the attached angular spring. The spring tries to rotate the connected bodies so that they make this angle.
			</summary> 
			<param name="angle"> Angle in degrees. The provided value will be saturated in the range [-180; 180].  </param> 
		</member>
		<member name="M:Unigine.JointCylindrical.getAngularAngle">
			<summary>
			Returns the target angle of the attached angular spring. The spring tries to rotate the connected bodies so that they make this angle.
			</summary>  
			<returns>Target angle in degrees.</returns>
		</member>
		<member name="M:Unigine.JointCylindrical.setAngularDamping(float)">
			<summary>
			Sets an angular damping of the joint.
			</summary> 
			<param name="damping"> Angular damping. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.JointCylindrical.getAngularDamping">
			<summary>
			Returns the angular damping of the joint.
			</summary>  
			<returns>Angular damping.</returns>
		</member>
		<member name="M:Unigine.JointCylindrical.setAngularLimitFrom(float)">
			<summary>
			Sets a low rotation limit angle. Rotation limit specifies how much a connected body can rotate around the joint axis.
			</summary> 
			<param name="from"> Angle in degrees. The provided value will be saturated in the range [-180; 180].  </param> 
		</member>
		<member name="M:Unigine.JointCylindrical.getAngularLimitFrom">
			<summary>
			Returns the low rotation limit angle. Rotation limit specifies how much a connected body can rotate around the joint axis.
			</summary>  
			<returns>Low rotation limit angle in degrees.</returns>
		</member>
		<member name="M:Unigine.JointCylindrical.setAngularLimitTo(float)">
			<summary>
			Sets a high rotation limit angle. Rotation limit specifies how much a connected body can rotate around the joint axis.
			</summary> 
			<param name="to"> Angle in degrees. The provided value will be saturated in the range [-180; 180].  </param> 
		</member>
		<member name="M:Unigine.JointCylindrical.getAngularLimitTo">
			<summary>
			Returns the high rotation limit angle. Rotation limit specifies how much a connected body can rotate around the joint axis
			</summary>  
			<returns>High rotation limit angle in degrees.</returns>
		</member>
		<member name="M:Unigine.JointCylindrical.setAngularSpring(float)">
			<summary>
			Sets a rigidity coefficient of the angular spring.
			</summary> 
			<param name="spring"> Rigidity coefficient. If a negative value is provided, 0 will be used instead. 0 detaches the spring.  </param> 
		</member>
		<member name="M:Unigine.JointCylindrical.getAngularSpring">
			<summary>
			Returns the rigidity coefficient of the angular spring. 0 means that the spring is not attached.
			</summary>  
			<returns>Rigidity coefficient.</returns>
		</member>
		<member name="M:Unigine.JointCylindrical.setAngularTorque(float)">
			<summary>
			Sets a maximum torque of the angular motor.
			</summary> 
			<param name="torque"> Maximum torque. If a negative value is provided, 0 will be used instead. 0 detaches the motor.  </param> 
		</member>
		<member name="M:Unigine.JointCylindrical.getAngularTorque">
			<summary>
			Returns the maximum torque of the attached angular motor. 0 means that the motor is not attached.
			</summary>  
			<returns>Maximum torque.</returns>
		</member>
		<member name="M:Unigine.JointCylindrical.setAngularVelocity(float)">
			<summary>
			Sets a target velocity of the attached angular motor.
			</summary> 
			<param name="velocity"> Velocity in radians per second. </param> 
		</member>
		<member name="M:Unigine.JointCylindrical.getAngularVelocity">
			<summary>
			Returns the target velocity of the attached angular motor.
			</summary>  
			<returns>Target velocity in radians per second.</returns>
		</member>
		<member name="M:Unigine.JointCylindrical.setAxis0(Unigine.Math.vec3)">
			<summary>
			Sets an axis of the first connected body.
			</summary> 
			<param name="axis0"> Axis of the first body. The provided vector will be normalized. </param> 
		</member>
		<member name="M:Unigine.JointCylindrical.getAxis0">
			<summary>
			Returns the axis of the first connected body.
			</summary>  
			<returns>Axis of the first body.</returns>
		</member>
		<member name="M:Unigine.JointCylindrical.setAxis1(Unigine.Math.vec3)">
			<summary>
			Sets an axis of the second connected body.
			</summary> 
			<param name="axis1"> Axis of the second body. The provided vector will be normalized. </param> 
		</member>
		<member name="M:Unigine.JointCylindrical.getAxis1">
			<summary>
			Returns the axis of the second connected body.
			</summary>  
			<returns>Axis of the second body.</returns>
		</member>
		<member name="M:Unigine.JointCylindrical.getCurrentAngularAngle">
			<summary>
			Returns the current angle between the bodies.
			</summary>  
			<returns>Current angle in degrees.</returns>
		</member>
		<member name="M:Unigine.JointCylindrical.getCurrentAngularVelocity">
			<summary>
			Returns the current velocity of the angular motor.
			</summary>  
			<returns>Current velocity in radians per second.</returns>
		</member>
		<member name="M:Unigine.JointCylindrical.getCurrentLinearDistance">
			<summary>
			Returns the current distance between the bodies.
			</summary>  
			<returns>Current distance in units.</returns>
		</member>
		<member name="M:Unigine.JointCylindrical.getCurrentLinearVelocity">
			<summary>
			Returns the current velocity of the linear motor.
			</summary>  
			<returns>Current velocity in units per second.</returns>
		</member>
		<member name="M:Unigine.JointCylindrical.setLinearDamping(float)">
			<summary>
			Sets a linear damping of the joint.
			</summary> 
			<param name="damping"> Linear damping. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.JointCylindrical.getLinearDamping">
			<summary>
			Returns the linear damping of the joint.
			</summary>  
			<returns>Linear damping.</returns>
		</member>
		<member name="M:Unigine.JointCylindrical.setLinearDistance(float)">
			<summary>
			Sets a target distance of the attached linear spring. The spring tries to move the connected bodies so that to keep this distance between them.
			</summary> 
			<param name="distance"> Target distance in units. </param> 
		</member>
		<member name="M:Unigine.JointCylindrical.getLinearDistance">
			<summary>
			Returns the target distance of the attached linear spring. The spring tries to move the connected bodies so that to keep this distance between them.
			</summary>  
			<returns>Target distance in units.</returns>
		</member>
		<member name="M:Unigine.JointCylindrical.setLinearForce(float)">
			<summary>
			Sets a maximum force of the attached linear motor.
			</summary> 
			<param name="force"> Maximum force. If a negative value is provided, 0 will be used instead. 0 detaches the motor.  </param> 
		</member>
		<member name="M:Unigine.JointCylindrical.getLinearForce">
			<summary>
			Returns the maximum force of the attached linear motor. 0 means that the motor is not attached.
			</summary>  
			<returns>Maximum force.</returns>
		</member>
		<member name="M:Unigine.JointCylindrical.setLinearLimitFrom(float)">
			<summary>
			Sets a low limit distance. This limit specifies how far a connected body can move along the joint axis.
			</summary> 
			<param name="from"> Distance in units. </param> 
		</member>
		<member name="M:Unigine.JointCylindrical.getLinearLimitFrom">
			<summary>
			Returns the low limit distance. This limit specifies how far a connected body can move along the joint axis.
			</summary>  
			<returns>Low limit distance in units.</returns>
		</member>
		<member name="M:Unigine.JointCylindrical.setLinearLimitTo(float)">
			<summary>
			Sets a high limit distance. This limit specifies how far a connected body can move along the joint axis.
			</summary> 
			<param name="to"> Distance in units. </param> 
		</member>
		<member name="M:Unigine.JointCylindrical.getLinearLimitTo">
			<summary>
			Returns the high limit distance. This limit specifies how far a connected body can move along the joint axis.
			</summary>  
			<returns>High limit distance in units.</returns>
		</member>
		<member name="M:Unigine.JointCylindrical.setLinearSpring(float)">
			<summary>
			Sets a rigidity coefficient of the linear spring.
			</summary> 
			<param name="spring"> Rigidity coefficient. If a negative value is provided, 0 will be used instead. 0 detaches the spring.  </param> 
		</member>
		<member name="M:Unigine.JointCylindrical.getLinearSpring">
			<summary>
			Returns the rigidity coefficient of the linear spring. 0 means that the spring is not attached.
			</summary>  
			<returns>Rigidity coefficient.</returns>
		</member>
		<member name="M:Unigine.JointCylindrical.setLinearVelocity(float)">
			<summary>
			Sets a target velocity of the attached linear motor.
			</summary> 
			<param name="velocity"> Target velocity in units per second. </param> 
		</member>
		<member name="M:Unigine.JointCylindrical.getLinearVelocity">
			<summary>
			Returns the target velocity of the attached linear motor.
			</summary>  
			<returns>Target velocity in units per second.</returns>
		</member>
		<member name="M:Unigine.JointCylindrical.setWorldAxis(Unigine.Math.vec3)">
			<summary>
			Sets a joint axis. This method updates axes of the connected bodies.
			</summary> 
			<param name="axis"> Joint axis. </param> 
		</member>
		<member name="M:Unigine.JointCylindrical.getWorldAxis">
			<summary>
			Returns the joint axis. The joint axis is calculated based on the axes of the connected bodies.
			</summary>  
			<returns>Joint axis.</returns>
		</member>
		<member name="M:Unigine.JointFixed.#ctor">
			<summary>
			Constructor. Creates a joint with an anchor at the origin of the world coordinates.
			</summary>  
		</member>
		<member name="M:Unigine.JointFixed.#ctor(Unigine.Ptr{Unigine.Body},Unigine.Ptr{Unigine.Body})">
			<summary>
			Constructor. Creates a joint connecting two given bodies. An anchor is placed between centers of mass of the bodies.
			</summary> 
			<param name="body0"> First body to be connected with the joint. </param>
			<param name="body1"> Second body to be connected with the joint. </param> 
		</member>
		<member name="M:Unigine.JointFixed.#ctor(Unigine.Ptr{Unigine.Body},Unigine.Ptr{Unigine.Body},Unigine.Math.Vec3)">
			<summary>
			Constructor. Creates a fixed joint connecting two given bodies with an anchor placed at specified coordinates.
			</summary> 
			<param name="body0"> First body to be connected with the joint. </param>
			<param name="body1"> Second body to be connected with the joint. </param>
			<param name="anchor"> Anchor coordinates. </param> 
		</member>
		<member name="M:Unigine.JointFixed.setRotation0(Unigine.Math.mat3)">
			<summary>
			Sets a rotation matrix of the anchor point in a system of coordinates of the first connected body.
			</summary> 
			<param name="rotation0"> Rotation matrix in the body coordinate space. </param> 
		</member>
		<member name="M:Unigine.JointFixed.getRotation0">
			<summary>
			Gets a rotation matrix of the anchor point in a system of coordinates of the first connected body.
			</summary>  
			<returns>Returns a rotation matrix of the anchor point in a system of coordinates of the first connected body.</returns>
		</member>
		<member name="M:Unigine.JointFixed.setRotation1(Unigine.Math.mat3)">
			<summary>
			Sets a rotation matrix of the anchor point in a system of coordinates of the second connected body.
			</summary> 
			<param name="rotation1"> Rotation matrix in the body coordinate space. </param> 
		</member>
		<member name="M:Unigine.JointFixed.getRotation1">
			<summary>
			Gets a rotation matrix of the anchor point in a system of coordinates of the second connected body.
			</summary>  
			<returns>Returns a rotation matrix of the anchor point in a system of coordinates of the second connected body.</returns>
		</member>
		<member name="M:Unigine.JointFixed.setWorldRotation(Unigine.Math.mat3)">
			<summary>
			Sets a rotation matrix of the anchor point in the world system of coordinates.
			</summary> 
			<param name="rotation"> Rotation matrix in the world coordinate space. </param> 
		</member>
		<member name="M:Unigine.JointFixed.getWorldRotation">
			<summary>
			Gets a rotation matrix of the anchor point in the world system of coordinates.
			</summary>  
			<returns>Returns a rotation matrix of the anchor point in the world system of coordinates.</returns>
		</member>
		<member name="M:Unigine.JointHinge.#ctor">
			<summary>
			Constructor. Creates a hinge joint with an anchor at the origin of the world coordinates.
			</summary>  
		</member>
		<member name="M:Unigine.JointHinge.#ctor(Unigine.Ptr{Unigine.Body},Unigine.Ptr{Unigine.Body})">
			<summary>
			Constructor. Creates a hinge joint connecting two given bodies. An anchor is placed between centers of mass of the bodies.
			</summary> 
			<param name="body0"> First body to be connected with the joint. </param>
			<param name="body1"> Second body to be connected with the joint. </param> 
		</member>
		<member name="M:Unigine.JointHinge.#ctor(Unigine.Ptr{Unigine.Body},Unigine.Ptr{Unigine.Body},Unigine.Math.Vec3,Unigine.Math.vec3)">
			<summary>
			Constructor. Creates a hinge joint connecting two given bodies with specified axis coordinates and an anchor placed at specified coordinates.
			</summary> 
			<param name="body0"> First body to be connected with the joint. </param>
			<param name="body1"> Second body to be connected with the joint. </param>
			<param name="anchor"> Anchor coordinates. </param>
			<param name="axis"> Axis coordinates. </param> 
		</member>
		<member name="M:Unigine.JointHinge.setAngularAngle(float)">
			<summary>
			Sets a target angle of the attached angular spring. The spring tries to rotate the connected bodies so that they make this angle.
			</summary> 
			<param name="angle"> Angle in degrees. The provided value will be saturated in the range [-180; 180].  </param> 
		</member>
		<member name="M:Unigine.JointHinge.getAngularAngle">
			<summary>
			Returns the target angle of the attached angular spring. The spring tries to rotate the connected bodies so that they make this angle.
			</summary>  
			<returns>Target angle in degrees.</returns>
		</member>
		<member name="M:Unigine.JointHinge.setAngularDamping(float)">
			<summary>
			Sets an angular damping of the joint.
			</summary> 
			<param name="damping"> Angular damping. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.JointHinge.getAngularDamping">
			<summary>
			Returns the angular damping of the joint.
			</summary>  
			<returns>Angular damping.</returns>
		</member>
		<member name="M:Unigine.JointHinge.setAngularLimitFrom(float)">
			<summary>
			Sets a low rotation limit angle. Rotation limit specifies how much a connected body can rotate around the joint axis.
			</summary> 
			<param name="from"> Angle in degrees. The provided value will be saturated in the range [-180; 180].  </param> 
		</member>
		<member name="M:Unigine.JointHinge.getAngularLimitFrom">
			<summary>
			Returns the low rotation limit angle. Rotation limit specifies how much a connected body can rotate around the joint axis.
			</summary>  
			<returns>Low rotation limit angle in degrees.</returns>
		</member>
		<member name="M:Unigine.JointHinge.setAngularLimitTo(float)">
			<summary>
			Sets a high rotation limit angle. Rotation limit specifies how much a connected body can rotate around the joint axis.
			</summary> 
			<param name="to"> Angle in degrees. The provided value will be saturated in the range [-180; 180].  </param> 
		</member>
		<member name="M:Unigine.JointHinge.getAngularLimitTo">
			<summary>
			Returns the high rotation limit angle. Rotation limit specifies how much a connected body can rotate around the joint axis.
			</summary>  
			<returns>High rotation limit angle in degrees.</returns>
		</member>
		<member name="M:Unigine.JointHinge.setAngularSpring(float)">
			<summary>
			Sets a rigidity coefficient of the angular spring.
			</summary> 
			<param name="spring"> Rigidity coefficient. If a negative value is provided, 0 will be used instead. 0 detaches the spring.  </param> 
		</member>
		<member name="M:Unigine.JointHinge.getAngularSpring">
			<summary>
			Returns the rigidity coefficient of the angular spring. 0 means that the spring is not attached.
			</summary>  
			<returns>Rigidity coefficient.</returns>
		</member>
		<member name="M:Unigine.JointHinge.setAngularTorque(float)">
			<summary>
			Sets a maximum torque of the angular motor.
			</summary> 
			<param name="torque"> Maximum torque. If a negative value is provided, 0 will be used instead. 0 detaches the motor.  </param> 
		</member>
		<member name="M:Unigine.JointHinge.getAngularTorque">
			<summary>
			Returns the maximum torque of the attached angular motor. 0 means that the motor is not attached.
			</summary>  
			<returns>Maximum torque.</returns>
		</member>
		<member name="M:Unigine.JointHinge.setAngularVelocity(float)">
			<summary>
			Sets a target velocity of the attached angular motor.
			</summary> 
			<param name="velocity"> Velocity in radians per second. </param> 
		</member>
		<member name="M:Unigine.JointHinge.getAngularVelocity">
			<summary>
			Returns the target velocity of the attached angular motor.
			</summary>  
			<returns>Target velocity in radians per second.</returns>
		</member>
		<member name="M:Unigine.JointHinge.setAxis0(Unigine.Math.vec3)">
			<summary>
			Sets an axis of the first connected body.
			</summary> 
			<param name="axis0"> Axis of the first body. The provided vector will be normalized. </param> 
		</member>
		<member name="M:Unigine.JointHinge.getAxis0">
			<summary>
			Returns the axis of the first connected body.
			</summary>  
			<returns>Axis of the first body.</returns>
		</member>
		<member name="M:Unigine.JointHinge.setAxis1(Unigine.Math.vec3)">
			<summary>
			Sets an axis of the second connected body.
			</summary> 
			<param name="axis1"> Axis of the second body. The provided vector will be normalized. </param> 
		</member>
		<member name="M:Unigine.JointHinge.getAxis1">
			<summary>
			Returns the axis of the second connected body.
			</summary>  
			<returns>Axis of the second body.</returns>
		</member>
		<member name="M:Unigine.JointHinge.getCurrentAngularAngle">
			<summary>
			Returns the current angle between the bodies.
			</summary>  
			<returns>Current angle in degrees.</returns>
		</member>
		<member name="M:Unigine.JointHinge.getCurrentAngularVelocity">
			<summary>
			Returns the current velocity of the motor, i.e. the difference between angular velocities of two bodies connected with a hinge relative the hinge axis.					This function returns the valid velocity only if both bodies are of BodyRigid type. Otherwise, 0 is returned.
			</summary>  
			<returns>Current motor velocity in radians per second.</returns>
		</member>
		<member name="M:Unigine.JointHinge.setWorldAxis(Unigine.Math.vec3)">
			<summary>
			Sets a joint axis. This method updates axes of the connected bodies.
			</summary> 
			<param name="axis"> Joint axis. </param> 
		</member>
		<member name="M:Unigine.JointHinge.getWorldAxis">
			<summary>
			Returns the joint axis. The joint axis is calculated based on the axes of the connected bodies.
			</summary>  
			<returns>Joint axis.</returns>
		</member>
		<member name="M:Unigine.JointParticles.#ctor">
			<summary>
			Constructor. Creates a particle joint with an anchor at the origin of the world coordinates.
			</summary>  
		</member>
		<member name="M:Unigine.JointParticles.#ctor(Unigine.Ptr{Unigine.Body},Unigine.Ptr{Unigine.Body})">
			<summary>
			Constructor. Creates a particle joint connecting two given bodies. An anchor is placed in the center of the body to which the cloth or rope is pinned.
			</summary> 
			<param name="body0"> First body to be connected with the joint. It can be one of the following:BodyRigidBodyRagdollBodyDummy </param>
			<param name="body1"> Second body to be connected with the joint. It can be one of the following:BodyClothBodyRope </param> 
		</member>
		<member name="M:Unigine.JointParticles.#ctor(Unigine.Ptr{Unigine.Body},Unigine.Ptr{Unigine.Body},Unigine.Math.Vec3,Unigine.Math.vec3)">
			<summary>
			Constructor. Creates a particles joint connecting two given bodies with specified pinning area size and an anchor placed at specified coordinates.
			</summary> 
			<param name="body0"> First body to be connected with the joint. It can be one of the following:BodyRigidBodyRagdollBodyDummy </param>
			<param name="body1"> Second body to be connected with the joint. It can be one of the following:BodyClothBodyRope </param>
			<param name="anchor"> Anchor coordinates. </param>
			<param name="size"> Area for pinning vertices of cloth or rope body to another body. </param> 
		</member>
		<member name="M:Unigine.JointParticles.getNumParticles">
			<summary>
			Returns the total number of pinned particles of the cloth or rope body.
			</summary>  
			<returns>The number of pinned particles.</returns>
		</member>
		<member name="M:Unigine.JointParticles.getParticleMass(int)">
			<summary>
			Returns the mass of the pinned particle of the cloth or rope body.
			</summary> 
			<param name="num"> Particle number. </param> 
			<returns>Particle mass.</returns>
		</member>
		<member name="M:Unigine.JointParticles.getParticlePosition(int)">
			<summary>
			Returns the position of the pinned particle of the cloth or rope body.
			</summary> 
			<param name="num"> Particle number. </param> 
			<returns>Particle position.</returns>
		</member>
		<member name="M:Unigine.JointParticles.setSize(Unigine.Math.vec3)">
			<summary>
			Updates a size of the area for pinning vertices of cloth or rope body to another body.
			</summary> 
			<param name="size"> Size of the area to be pinned. </param> 
		</member>
		<member name="M:Unigine.JointParticles.getSize">
			<summary>
			Returns the current size of the area of pinned vertices of cloth or rope body to another body.
			</summary>  
			<returns>Size of the pinned area.</returns>
		</member>
		<member name="M:Unigine.JointParticles.setThreshold(float)">
			<summary>
			Updates a threshold that determines the distance for pinning vertices of cloth or rope body to another body. If vertices are closer than the threshold, they are pinned together; otherwise, particles stay loose.
			</summary> 
			<param name="threshold"> Threshold of pinning distance. </param> 
		</member>
		<member name="M:Unigine.JointParticles.getThreshold">
			<summary>
			Returns the current threshold that determines the distance for pinning vertices of cloth or rope body to another body. If vertices are closer than the threshold, they are pinned together; otherwise, particles stay loose.
			</summary>  
			<returns>Threshold of pinning distance.</returns>
		</member>
		<member name="M:Unigine.JointParticles.clearParticles">
			<summary>
			Unpins the cloth or rope body completely.
			</summary>  
		</member>
		<member name="M:Unigine.JointPath.#ctor">
			<summary>
			Constructor. Creates a path joint with an anchor at the origin of the world coordinates.
			</summary>  
		</member>
		<member name="M:Unigine.JointPath.#ctor(Unigine.Ptr{Unigine.Body},Unigine.Ptr{Unigine.Body})">
			<summary>
			Constructor. Creates a path joint connecting two given bodies. An anchor is placed in the center of the rigid body attached the path body.
			</summary> 
			<param name="body0"> BodyRigid to be connected with the joint. </param>
			<param name="body1"> BodyPath to be connected with the joint. </param> 
		</member>
		<member name="M:Unigine.JointPath.#ctor(Unigine.Ptr{Unigine.Body},Unigine.Ptr{Unigine.Body},Unigine.Math.Vec3)">
			<summary>
			Constructor. Creates a path joint connecting two given bodies with an anchor placed at specified coordinates.
			</summary> 
			<param name="body0"> BodyRigid to be connected with the joint. </param>
			<param name="body1"> BodyPath to be connected with the joint. </param>
			<param name="anchor"> Anchor coordinates. </param> 
		</member>
		<member name="M:Unigine.JointPath.getCurrentLinearVelocity">
			<summary>
			Returns the current linear velocity of the attached motor.
			</summary>  
			<returns>Current linear velocity in units per second.</returns>
		</member>
		<member name="M:Unigine.JointPath.setLinearDamping(float)">
			<summary>
			Sets damping factor of linear velocities of bodies connected by the joint.
			</summary> 
			<param name="damping"> Linear damping to be set. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.JointPath.getLinearDamping">
			<summary>
			Returns the current damping factor for linear velocities of bodies connected by the joint.
			</summary>  
			<returns>Linear damping.</returns>
		</member>
		<member name="M:Unigine.JointPath.setLinearForce(float)">
			<summary>
			Sets a maximum force of the attached motor. 0 means that the motor is not attached.
			</summary> 
			<param name="force"> Maximum force to be set. If a negative value is provided, 0 will be used instead. 0 detaches the motor. </param> 
		</member>
		<member name="M:Unigine.JointPath.getLinearForce">
			<summary>
			Returns the maximum force of the attached motor.
			</summary>  
			<returns>Maximum force.</returns>
		</member>
		<member name="M:Unigine.JointPath.setLinearVelocity(float)">
			<summary>
			Sets a target linear velocity of the attached motor.
			</summary> 
			<param name="velocity"> Target velocity in units per second. </param> 
		</member>
		<member name="M:Unigine.JointPath.getLinearVelocity">
			<summary>
			Returns the current linear velocity of the attached motor.
			</summary>  
			<returns>Target velocity in units per second.</returns>
		</member>
		<member name="M:Unigine.JointPath.setRotation0(Unigine.Math.mat3)">
			<summary>
			Sets a rotation matrix of the anchor point in a system of coordinates of the connected rigid body.
			</summary> 
			<param name="rotation0"> Rotation matrix in the body-space coordinates. </param> 
		</member>
		<member name="M:Unigine.JointPath.getRotation0">
			<summary>
			Gets a rotation matrix of the anchor point in a system of coordinates of the connected rigid body.
			</summary>  
			<returns>Returns a rotation matrix of the anchor point in a system of coordinates of the connected rigid body.</returns>
		</member>
		<member name="M:Unigine.JointPath.setWorldRotation(Unigine.Math.mat3)">
			<summary>
			Sets a rotation matrix of the anchor point in the world coordinates.
			</summary> 
			<param name="rotation"> Rotation matrix in the world-space coordinates. </param> 
		</member>
		<member name="M:Unigine.JointPath.getWorldRotation">
			<summary>
			Returns rotation matrix of the anchor point in the world coordinates.
			</summary>  
			<returns>Rotation matrix in the world-space coordinates.</returns>
		</member>
		<member name="M:Unigine.JointPrismatic.#ctor">
			<summary>
			Constructor. Creates a prismatic joint with an anchor at the origin of the world coordinates.
			</summary>  
		</member>
		<member name="M:Unigine.JointPrismatic.#ctor(Unigine.Ptr{Unigine.Body},Unigine.Ptr{Unigine.Body})">
			<summary>
			Constructor. Creates a prismatic joint connecting two given bodies. An anchor is placed between centers of mass of the bodies.
			</summary> 
			<param name="body0"> First body to be connected with the joint. </param>
			<param name="body1"> Second body to be connected with the joint. </param> 
		</member>
		<member name="M:Unigine.JointPrismatic.#ctor(Unigine.Ptr{Unigine.Body},Unigine.Ptr{Unigine.Body},Unigine.Math.Vec3,Unigine.Math.vec3)">
			<summary>
			Constructor. Creates a prismatic joint connecting two given bodies with specified axis coordinates and an anchor placed at specified coordinates.
			</summary> 
			<param name="body0"> First body to be connected with the joint. </param>
			<param name="body1"> Second body to be connected with the joint. </param>
			<param name="anchor"> Anchor coordinates. </param>
			<param name="size"> Axis coordinates. </param> 
		</member>
		<member name="M:Unigine.JointPrismatic.setAxis0(Unigine.Math.vec3)">
			<summary>
			Sets a joint axis in the local coordinates of the first body.
			</summary> 
			<param name="axis0"> Joint axis in the coordinates of the first body. </param> 
		</member>
		<member name="M:Unigine.JointPrismatic.getAxis0">
			<summary>
			Returns the joint axis in the local coordinates of the first body.
			</summary>  
			<returns>Joint axis in the coordinates of the first body.</returns>
		</member>
		<member name="M:Unigine.JointPrismatic.getCurrentLinearDistance">
			<summary>
			Returns the current distance between the bodies.
			</summary>  
			<returns>Current distance in units.</returns>
		</member>
		<member name="M:Unigine.JointPrismatic.getCurrentLinearVelocity">
			<summary>
			Returns the current velocity of the attached motor.
			</summary>  
			<returns>Current velocity in units per second.</returns>
		</member>
		<member name="M:Unigine.JointPrismatic.setLinearDamping(float)">
			<summary>
			Sets a linear damping of the joint.
			</summary> 
			<param name="damping"> Linear damping. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.JointPrismatic.getLinearDamping">
			<summary>
			Returns the linear damping of the joint.
			</summary>  
			<returns>Linear damping.</returns>
		</member>
		<member name="M:Unigine.JointPrismatic.setLinearDistance(float)">
			<summary>
			Sets a target distance of the attached spring. The spring tries to move the connected bodies so that to keep this distance between them.
			</summary> 
			<param name="distance"> Target distance in units. </param> 
		</member>
		<member name="M:Unigine.JointPrismatic.getLinearDistance">
			<summary>
			Returns the target distance of the attached spring. The spring tries to move the connected bodies so that to keep this distance between them.
			</summary>  
			<returns>Target distance in units.</returns>
		</member>
		<member name="M:Unigine.JointPrismatic.setLinearForce(float)">
			<summary>
			Sets a maximum force of the attached motor.
			</summary> 
			<param name="force"> Maximum force. If a negative value is provided, 0 will be used instead. 0 detaches the motor.  </param> 
		</member>
		<member name="M:Unigine.JointPrismatic.getLinearForce">
			<summary>
			Returns the maximum force of the attached motor. 0 means that the motor is not attached.
			</summary>  
			<returns>Maximum force.</returns>
		</member>
		<member name="M:Unigine.JointPrismatic.setLinearLimitFrom(float)">
			<summary>
			Sets a low limit distance. This limit specifies how far a connected body can move along the joint axis.
			</summary> 
			<param name="from"> Distance in units. </param> 
		</member>
		<member name="M:Unigine.JointPrismatic.getLinearLimitFrom">
			<summary>
			Returns the low limit distance. This limit specifies how far a connected body can move along the joint axis.
			</summary>  
			<returns>Low limit distance in units.</returns>
		</member>
		<member name="M:Unigine.JointPrismatic.setLinearLimitTo(float)">
			<summary>
			Sets a high limit distance. This limit specifies how far a connected body can move along the joint axis.
			</summary> 
			<param name="to"> Distance in units. </param> 
		</member>
		<member name="M:Unigine.JointPrismatic.getLinearLimitTo">
			<summary>
			Returns the high limit distance. This limit specifies how far a connected body can move along the joint axis.
			</summary>  
			<returns>High limit distance in units.</returns>
		</member>
		<member name="M:Unigine.JointPrismatic.setLinearSpring(float)">
			<summary>
			Sets a rigidity coefficient of the spring.
			</summary> 
			<param name="spring"> Rigidity coefficient. If a negative value is provided, 0 will be used instead. 0 detaches the spring.  </param> 
		</member>
		<member name="M:Unigine.JointPrismatic.getLinearSpring">
			<summary>
			Returns the rigidity coefficient of the spring. 0 means that the spring is not attached.
			</summary>  
			<returns>Rigidity coefficient.</returns>
		</member>
		<member name="M:Unigine.JointPrismatic.setLinearVelocity(float)">
			<summary>
			Sets a target velocity of the attached motor.
			</summary> 
			<param name="velocity"> Target velocity in units per second. </param> 
		</member>
		<member name="M:Unigine.JointPrismatic.getLinearVelocity">
			<summary>
			Returns the target velocity of the attached motor.
			</summary>  
			<returns>Target velocity in units per second.</returns>
		</member>
		<member name="M:Unigine.JointPrismatic.setRotation0(Unigine.Math.mat3)">
			<summary>
			Sets a rotation matrix of the anchor point in a system of coordinates of the first connected body.
			</summary> 
			<param name="rotation0"> Rotation matrix in the body coordinate space. </param> 
		</member>
		<member name="M:Unigine.JointPrismatic.getRotation0">
			<summary>
			Gets a rotation matrix of the anchor point in a system of coordinates of the first connected body.
			</summary>  
			<returns>Returns a rotation matrix of the anchor point in a system of coordinates of the first connected body.</returns>
		</member>
		<member name="M:Unigine.JointPrismatic.setRotation1(Unigine.Math.mat3)">
			<summary>
			Sets a rotation matrix of the anchor point in a system of coordinates of the second connected body.
			</summary> 
			<param name="rotation1"> Rotation matrix in the body coordinate space. </param> 
		</member>
		<member name="M:Unigine.JointPrismatic.getRotation1">
			<summary>
			Gets a rotation matrix of the anchor point in a system of coordinates of the second connected body.
			</summary>  
			<returns>Returns a rotation matrix of the anchor point in a system of coordinates of the second connected body.</returns>
		</member>
		<member name="M:Unigine.JointPrismatic.setWorldAxis(Unigine.Math.vec3)">
			<summary>
			Sets a joint axis in the world coordinates.
			</summary> 
			<param name="axis"> Joint axis in the world coordinates. </param> 
		</member>
		<member name="M:Unigine.JointPrismatic.getWorldAxis">
			<summary>
			Returns the joint axis in the world coordinates.
			</summary>  
			<returns>Joint axis in the world coordinates.</returns>
		</member>
		<member name="M:Unigine.JointPrismatic.setWorldRotation(Unigine.Math.mat3)">
			<summary>
			Sets a rotation matrix of the anchor point in the world system of coordinates.
			</summary> 
			<param name="rotation"> Rotation matrix in the world coordinate space. </param> 
		</member>
		<member name="M:Unigine.JointPrismatic.getWorldRotation">
			<summary>
			Gets a rotation matrix of the anchor point in the world system of coordinates.
			</summary>  
			<returns>Returns a rotation matrix of the anchor point in the world system of coordinates.</returns>
		</member>
		<member name="M:Unigine.JointSuspension.#ctor">
			<summary>
			Constructor. Creates a suspension joint with an anchor at the origin of the world coordinates.
			</summary>  
		</member>
		<member name="M:Unigine.JointSuspension.#ctor(Unigine.Ptr{Unigine.Body},Unigine.Ptr{Unigine.Body})">
			<summary>
			Constructor. Creates a suspension joint connecting two given bodies. An anchor is placed between centers of mass of the bodies.
			</summary> 
			<param name="body0"> Frame to be connected with the joint. </param>
			<param name="body1"> Wheel to be connected with the joint. </param> 
		</member>
		<member name="M:Unigine.JointSuspension.#ctor(Unigine.Ptr{Unigine.Body},Unigine.Ptr{Unigine.Body},Unigine.Math.Vec3,Unigine.Math.vec3,Unigine.Math.vec3)">
			<summary>
			Constructor. Creates a suspension joint connecting two given bodies with specified suspension and spindle axis coordinates and an anchor placed at specified coordinates.
			</summary> 
			<param name="body0"> Frame to be connected with the joint. </param>
			<param name="body1"> Wheel to be connected with the joint. </param>
			<param name="anchor"> Anchor coordinates. </param>
			<param name="axis0"> Suspension axis coordinates. </param>
			<param name="axis1"> Wheel spindle axis coordinates. </param> 
		</member>
		<member name="M:Unigine.JointSuspension.setAngularDamping(float)">
			<summary>
			Sets an angular damping of the joint (wheel rotation damping).
			</summary> 
			<param name="damping"> Angular damping. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.JointSuspension.getAngularDamping">
			<summary>
			Returns the angular damping of the joint (wheel rotation damping).
			</summary>  
			<returns>Angular damping.</returns>
		</member>
		<member name="M:Unigine.JointSuspension.setAngularTorque(float)">
			<summary>
			Sets a maximum torque of the attached angular motor.
			</summary> 
			<param name="torque"> Maximum torque. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.JointSuspension.getAngularTorque">
			<summary>
			Returns the maximum torque of the attached angular motor.
			</summary>  
			<returns>Maximum torque.</returns>
		</member>
		<member name="M:Unigine.JointSuspension.setAngularVelocity(float)">
			<summary>
			Sets a maximum velocity of wheel rotation.
			</summary> 
			<param name="velocity"> Velocity in radians per second. </param> 
		</member>
		<member name="M:Unigine.JointSuspension.getAngularVelocity">
			<summary>
			Returns the target velocity of wheel rotation.
			</summary>  
			<returns>Target velocity in radians per second.</returns>
		</member>
		<member name="M:Unigine.JointSuspension.setAxis00(Unigine.Math.vec3)">
			<summary>
			Sets coordinates of suspension axis, along which a wheel moves vertically. This is a shock absorber.
			</summary> 
			<param name="axis00"> Suspension axis. </param> 
		</member>
		<member name="M:Unigine.JointSuspension.getAxis00">
			<summary>
			Returns suspension axis coordinates.
			</summary>  
			<returns>Suspension axis.</returns>
		</member>
		<member name="M:Unigine.JointSuspension.setAxis10(Unigine.Math.vec3)">
			<summary>
								Sets a wheel spindle axis in coordinates of the frame (body 0): an axis around which a wheel rotates when moving forward (or backward).
			</summary> 
			<param name="axis10"> Wheel spindle axis in coordinates of the frame (body 0). </param> 
		</member>
		<member name="M:Unigine.JointSuspension.getAxis10">
			<summary>
			Returns the wheel spindle axis in coordinates of the frame (body 0).
			</summary>  
			<returns>Wheel spindle axis in coordinates of the frame (body 0).</returns>
		</member>
		<member name="M:Unigine.JointSuspension.setAxis11(Unigine.Math.vec3)">
			<summary>
			Sets a wheel spindle axis in coordinates of the wheel (body 1): an axis around which a wheel rotates when steering.
			</summary> 
			<param name="axis11"> Wheel spindle axis in coordinates of the wheel (body 1). </param> 
		</member>
		<member name="M:Unigine.JointSuspension.getAxis11">
			<summary>
			Returns the wheel spindle in coordinates of the wheel (body 1).
			</summary>  
			<returns>Wheel spindle axis in coordinates of the wheel (body 1).</returns>
		</member>
		<member name="M:Unigine.JointSuspension.getCurrentAngularVelocity">
			<summary>
			Returns the current velocity of wheel rotation.
			</summary>  
			<returns>Current velocity in radians per second.</returns>
		</member>
		<member name="M:Unigine.JointSuspension.getCurrentLinearDistance">
			<summary>
			Returns the current suspension compression.
			</summary>  
			<returns>Current suspension height in units.</returns>
		</member>
		<member name="M:Unigine.JointSuspension.setLinearDamping(float)">
			<summary>
			Sets a linear damping of the suspension.
			</summary> 
			<param name="damping"> Linear damping. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.JointSuspension.getLinearDamping">
			<summary>
			Returns the linear damping of the suspension.
			</summary>  
			<returns>Linear damping.</returns>
		</member>
		<member name="M:Unigine.JointSuspension.setLinearDistance(float)">
			<summary>
			Sets a target height of the suspension.
			</summary> 
			<param name="distance"> Height in units. </param> 
		</member>
		<member name="M:Unigine.JointSuspension.getLinearDistance">
			<summary>
			Returns the target height of the suspension.
			</summary>  
			<returns>Target height in units.</returns>
		</member>
		<member name="M:Unigine.JointSuspension.setLinearLimitFrom(float)">
			<summary>
			Sets a low limit of the suspension ride.
			</summary> 
			<param name="from"> Limit in units. </param> 
		</member>
		<member name="M:Unigine.JointSuspension.getLinearLimitFrom">
			<summary>
			Returns the low limit of the suspension ride.
			</summary>  
			<returns>Low limit in units.</returns>
		</member>
		<member name="M:Unigine.JointSuspension.setLinearLimitTo(float)">
			<summary>
			Sets a high limit of the suspension ride.
			</summary> 
			<param name="to"> Limit in units. </param> 
		</member>
		<member name="M:Unigine.JointSuspension.getLinearLimitTo">
			<summary>
			Returns the high limit of the suspension ride.
			</summary>  
			<returns>High limit in units.</returns>
		</member>
		<member name="M:Unigine.JointSuspension.setLinearSpring(float)">
			<summary>
			Sets a rigidity coefficient of the suspension.
			</summary> 
			<param name="spring"> Rigidity coefficient. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.JointSuspension.getLinearSpring">
			<summary>
			Returns the rigidity coefficient of the suspension.
			</summary>  
			<returns>Rigidity coefficient.</returns>
		</member>
		<member name="M:Unigine.JointSuspension.setWorldAxis0(Unigine.Math.vec3)">
			<summary>
			Sets suspension axis in the world coordinates.
			</summary> 
			<param name="axis0"> Suspension axis in the world coordinates. </param> 
		</member>
		<member name="M:Unigine.JointSuspension.getWorldAxis0">
			<summary>
			Returns the suspension axis in the world coordinates.
			</summary>  
			<returns>Suspension axis in the world coordinates.</returns>
		</member>
		<member name="M:Unigine.JointSuspension.setWorldAxis1(Unigine.Math.vec3)">
			<summary>
			Sets a wheel spindle axis in the world coordinates.
			</summary> 
			<param name="axis1"> Wheel spindle axis in the world coordinates. </param> 
		</member>
		<member name="M:Unigine.JointSuspension.getWorldAxis1">
			<summary>
			Returns the wheel spindle axis in the world coordinates.
			</summary>  
			<returns>Wheel spindle axis in the world coordinates.</returns>
		</member>
		<member name="M:Unigine.JointWheel.#ctor">
			<summary>
			Constructor. Creates a wheel joint with an anchor at the origin of the world coordinates.
			</summary>  
		</member>
		<member name="M:Unigine.JointWheel.#ctor(Unigine.Ptr{Unigine.Body},Unigine.Ptr{Unigine.Body})">
			<summary>
			Constructor. Creates a wheel joint connecting two given bodies. An anchor is placed between centers of mass of the bodies.
			</summary> 
			<param name="body0"> Frame to be connected with the joint. </param>
			<param name="body1"> Wheel to be connected with the joint. </param> 
		</member>
		<member name="M:Unigine.JointWheel.#ctor(Unigine.Ptr{Unigine.Body},Unigine.Ptr{Unigine.Body},Unigine.Math.Vec3,Unigine.Math.vec3,Unigine.Math.vec3)">
			<summary>
			Constructor. Creates a wheel joint connecting two given bodies with specified suspension and spindle axis coordinates and an anchor placed at specified coordinates.
			</summary> 
			<param name="body0"> Frame to be connected with the joint. </param>
			<param name="body1"> Wheel to be connected with the joint. </param>
			<param name="anchor"> Anchor coordinates. </param>
			<param name="axis0"> Suspension axis coordinates. </param>
			<param name="axis1"> Wheel spindle axis coordinates. </param> 
		</member>
		<member name="M:Unigine.JointWheel.setAngularDamping(float)">
			<summary>
			Sets an angular damping of the joint (wheel rotation damping).
			</summary> 
			<param name="damping"> Angular damping. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.JointWheel.getAngularDamping">
			<summary>
			Returns the angular damping of the joint (wheel rotation damping).
			</summary>  
			<returns>Angular damping.</returns>
		</member>
		<member name="M:Unigine.JointWheel.setAngularTorque(float)">
			<summary>
			Sets a maximum torque of the attached angular motor.
			</summary> 
			<param name="torque"> Maximum torque. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.JointWheel.getAngularTorque">
			<summary>
			Returns the maximum torque of the attached angular motor.
			</summary>  
			<returns>Maximum torque.</returns>
		</member>
		<member name="M:Unigine.JointWheel.setAngularVelocity(float)">
			<summary>
			Sets a maximum velocity of wheel rotation.
			</summary> 
			<param name="velocity"> Velocity in radians per second. </param> 
		</member>
		<member name="M:Unigine.JointWheel.getAngularVelocity">
			<summary>
			Returns the target velocity of wheel rotation.
			</summary>  
			<returns>Target velocity in radians per second.</returns>
		</member>
		<member name="M:Unigine.JointWheel.setAxis00(Unigine.Math.vec3)">
			<summary>
			Sets coordinates of suspension axis, along which a wheel moves vertically. This is a shock absorber.
			</summary> 
			<param name="axis00"> Suspension axis. </param> 
		</member>
		<member name="M:Unigine.JointWheel.getAxis00">
			<summary>
			Returns suspension axis coordinates.
			</summary>  
			<returns>Suspension axis.</returns>
		</member>
		<member name="M:Unigine.JointWheel.setAxis10(Unigine.Math.vec3)">
			<summary>
			Sets a wheel spindle axis in coordinates of the frame (body 0): an axis around which a wheel rotates when moving forward (or backward).
			</summary> 
			<param name="axis10"> Wheel spindle axis in coordinates of the frame (body 0). </param> 
		</member>
		<member name="M:Unigine.JointWheel.getAxis10">
			<summary>
			Returns the wheel spindle axis in coordinates of the frame (body 0).
			</summary>  
			<returns>Wheel spindle axis in coordinates of the frame (body 0).</returns>
		</member>
		<member name="M:Unigine.JointWheel.setAxis11(Unigine.Math.vec3)">
			<summary>
			Sets a wheel spindle axis in coordinates of the wheel (body 1): an axis around which a wheel rotates when steering.
			</summary> 
			<param name="axis11"> Wheel spindle axis in coordinates of the wheel (body 1). </param> 
		</member>
		<member name="M:Unigine.JointWheel.getAxis11">
			<summary>
			Returns the wheel spindle in coordinates of the wheel (body 1).
			</summary>  
			<returns>Wheel spindle axis in coordinates of the wheel (body 1).</returns>
		</member>
		<member name="M:Unigine.JointWheel.setBinormalAngle(float)">
			<summary>
			Sets a coefficient specifying how fast the optimal lateral force can be achieved. The larger this value, the more is the impulse produced by the tire.
			</summary> 
			<param name="angle"> Coefficient characterizing the tire lateral impulse. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.JointWheel.getBinormalAngle">
			<summary>
			Returns the coefficient specifying how fast the optimal lateral force can be achieved. The larger this value, the more is the impulse produced by the tire.
			</summary>  
			<returns>Coefficient characterizing the tire lateral impulse.</returns>
		</member>
		<member name="M:Unigine.JointWheel.setBinormalFriction(float)">
			<summary>
			Sets a lateral (sideways) friction of the tire.
			</summary> 
			<param name="friction"> Lateral friction. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.JointWheel.getBinormalFriction">
			<summary>
			Returns the lateral (sideways) friction of the tire.
			</summary>  
			<returns>Lateral friction.</returns>
		</member>
		<member name="M:Unigine.JointWheel.getContactNormal">
			<summary>
			Returns a normal of a point of contact with the ground, in world coordinates.
			</summary>  
			<returns>Normal.</returns>
		</member>
		<member name="M:Unigine.JointWheel.getContactObject">
			<summary>
			Returns an object representing the ground.
			</summary>  
			<returns>Ground object.</returns>
		</member>
		<member name="M:Unigine.JointWheel.getContactPoint">
			<summary>
			Returns a point of contact with the ground, in world coordinates.
			</summary>  
			<returns>Point coordinates.</returns>
		</member>
		<member name="M:Unigine.JointWheel.getContactShape">
			<summary>
			Returns a shape of the object representing the ground.
			</summary>  
			<returns>Shape of the ground object.</returns>
		</member>
		<member name="M:Unigine.JointWheel.getContactSurface">
			<summary>
			Returns a surface of a ground object, which is in contact.
			</summary>  
			<returns>Surface number.</returns>
		</member>
		<member name="M:Unigine.JointWheel.setCurrentAngularVelocity(float)">
			<summary>
			Sets the rotation velocity for the attached wheels. For example, it allows to reset it to zero and stop the car when necessary.
			</summary> 
			<param name="velocity"> Angular velocity in radians per second. </param> 
		</member>
		<member name="M:Unigine.JointWheel.getCurrentAngularVelocity">
			<summary>
			Returns the current rotation velocity of the attached wheels.
			</summary>  
			<returns>Current angular velocity in radians per second.</returns>
		</member>
		<member name="M:Unigine.JointWheel.setCurrentLinearDistance(float)">
			<summary>
			Sets suspension compression (i.e. the length of the suspension).
			</summary> 
			<param name="distance"> Suspension length in units. </param> 
		</member>
		<member name="M:Unigine.JointWheel.getCurrentLinearDistance">
			<summary>
			Returns the current suspension compression (i.e. the length of the suspension).
			</summary>  
			<returns>Current suspension length in units.</returns>
		</member>
		<member name="M:Unigine.JointWheel.getCurrentSlipAngle">
			<summary>
			Returns the current angle between the wheel direction and the frame direction.
			</summary>  
			<returns>Current slip angle in degrees.</returns>
		</member>
		<member name="M:Unigine.JointWheel.getCurrentSlipRatio">
			<summary>
			Returns the current ratio of wheel spin to ground speed.
			</summary>  
			<returns>Current slip ratio in percents. 0 means that the velocities are equal. If the throttle is pressed, the value will be positive. If the brake is pressed, the value will be negative. </returns>
		</member>
		<member name="M:Unigine.JointWheel.setPhysicsIntersectionMask(int)">
			<summary>
			Sets a physics intersection mask for the joint.
			</summary> 
			<param name="mask"> Integer, each bit of which is a mask. </param> 
		</member>
		<member name="M:Unigine.JointWheel.getPhysicsIntersectionMask">
			<summary>
			Returns an physics intersection mask mask of the joint.
			</summary>  
			<returns>Integer, each bit of which is a mask.</returns>
		</member>
		<member name="M:Unigine.JointWheel.setLinearDamping(float)">
			<summary>
			Sets a linear damping of the suspension.
			</summary> 
			<param name="damping"> Linear damping. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.JointWheel.getLinearDamping">
			<summary>
			Returns the linear damping of the suspension.
			</summary>  
			<returns>Linear damping.</returns>
		</member>
		<member name="M:Unigine.JointWheel.setLinearDistance(float)">
			<summary>
			Sets a target height of the suspension.
			</summary> 
			<param name="distance"> Height in units. </param> 
		</member>
		<member name="M:Unigine.JointWheel.getLinearDistance">
			<summary>
			Returns the target height of the suspension.
			</summary>  
			<returns>Target height in units.</returns>
		</member>
		<member name="M:Unigine.JointWheel.setLinearLimitFrom(float)">
			<summary>
			Sets a low limit of the suspension ride.
			</summary> 
			<param name="from"> Limit in units. </param> 
		</member>
		<member name="M:Unigine.JointWheel.getLinearLimitFrom">
			<summary>
			Returns the low limit of the suspension ride.
			</summary>  
			<returns>Low limit in units.</returns>
		</member>
		<member name="M:Unigine.JointWheel.setLinearLimitTo(float)">
			<summary>
			Sets a high limit of the suspension ride.
			</summary> 
			<param name="to"> Limit in units. </param> 
		</member>
		<member name="M:Unigine.JointWheel.getLinearLimitTo">
			<summary>
			Returns the high limit of the suspension ride.
			</summary>  
			<returns>High limit in units.</returns>
		</member>
		<member name="M:Unigine.JointWheel.setLinearSpring(float)">
			<summary>
			Sets a rigidity coefficient of the suspension.
			</summary> 
			<param name="spring"> Rigidity coefficient. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.JointWheel.getLinearSpring">
			<summary>
			Returns the rigidity coefficient of the suspension.
			</summary>  
			<returns>Rigidity coefficient.</returns>
		</member>
		<member name="M:Unigine.JointWheel.setTangentAngle(float)">
			<summary>
			Sets a coefficient specifying how fast the optimal longitudinal force can be achieved. The larger this value, the more is the impulse produced by the tire.
			</summary> 
			<param name="angle"> Coefficient characterizing the tire longitudinal impulse. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.JointWheel.getTangentAngle">
			<summary>
			Returns the coefficient specifying how fast the optimal longitudinal force can be achieved. The larger this value, the more is the impulse produced by the tire.
			</summary>  
			<returns>Coefficient characterizing the tire longitudinal impulse.</returns>
		</member>
		<member name="M:Unigine.JointWheel.setTangentFriction(float)">
			<summary>
			Sets a longitudinal (forward) friction of the tire.
			</summary> 
			<param name="friction"> Longitudinal friction. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.JointWheel.getTangentFriction">
			<summary>
			Returns the longitudinal (forward) friction of the tire.
			</summary>  
			<returns>Longitudinal friction.</returns>
		</member>
		<member name="M:Unigine.JointWheel.setWheelMass(float)">
			<summary>
			Sets a mass of the attached wheel.					If g (Earth's gravity) equals to 9.8 m/s						2, and 1 unit equals to 1 m, the mass is measured in kilograms.
			</summary> 
			<param name="mass"> Mass of the wheel. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.JointWheel.getWheelMass">
			<summary>
			Returns the mass of the attached wheel.					If g (Earth's gravity) equals to 9.8 m/s						2, and 1 unit equals to 1 m, the mass is measured in kilograms.
			</summary>  
			<returns>Mass of the wheel.</returns>
		</member>
		<member name="M:Unigine.JointWheel.setWheelRadius(float)">
			<summary>
			Sets a radius of the attached wheel.
			</summary> 
			<param name="radius"> Radius of the wheel in units. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.JointWheel.getWheelRadius">
			<summary>
			Returns the radius of the attached wheel.
			</summary>  
			<returns>Radius of the wheel in units.</returns>
		</member>
		<member name="M:Unigine.JointWheel.setWheelThreshold(float)">
			<summary>
			Sets a threshold difference between the wheel and ground velocities. When it is too small, the longitudinal force will be scaled down to prevent unnatural vibrations.
			</summary> 
			<param name="threshold"> Difference threshold. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.JointWheel.getWheelThreshold">
			<summary>
			Returns the threshold difference between the wheel and ground velocities. When it is too small, the longitudinal force will be scaled down to prevent unnatural vibrations.
			</summary>  
			<returns>Difference threshold.</returns>
		</member>
		<member name="M:Unigine.JointWheel.setWorldAxis0(Unigine.Math.vec3)">
			<summary>
			Sets suspension axis in the world coordinates.
			</summary> 
			<param name="axis0"> Suspension axis in the world coordinates. </param> 
		</member>
		<member name="M:Unigine.JointWheel.getWorldAxis0">
			<summary>
			Returns the suspension axis in the world coordinates.
			</summary>  
			<returns>Suspension axis in the world coordinates.</returns>
		</member>
		<member name="M:Unigine.JointWheel.setWorldAxis1(Unigine.Math.vec3)">
			<summary>
			Sets a wheel spindle axis in the world coordinates.
			</summary> 
			<param name="axis1"> Wheel spindle axis in the world coordinates. </param> 
		</member>
		<member name="M:Unigine.JointWheel.getWorldAxis1">
			<summary>
			Returns the wheel spindle axis in the world coordinates.
			</summary>  
			<returns>Wheel spindle axis in the world coordinates.</returns>
		</member>
		<member name="M:Unigine.Shape.getArea">
			<summary>
			Returns areas of shape projections on three axes: x, y, and z.
			</summary>  
			<returns>A triple of projection areas.</returns>
		</member>
		<member name="M:Unigine.Shape.setBody(Unigine.Ptr{Unigine.Body})">
			<summary>
			Sets a body, to which the shape belongs.
			</summary> 
			<param name="body"> Body, to which the shape belongs. </param> 
		</member>
		<member name="M:Unigine.Shape.getBody">
			<summary>
			Returns the body, to which the shape belongs.
			</summary>  
			<returns>Body, to which the shape belongs.</returns>
		</member>
		<member name="M:Unigine.Shape.setBodyShapeTransform(Unigine.Math.mat4)">
			<summary>
			Sets a transformation matrix for the shape (in the coordinates of the body). This matrix describes position and orientation of the shape. This method is identical to setShapeTransform().
			</summary> 
			<param name="transform"> Transformation matrix </param> 
		</member>
		<member name="M:Unigine.Shape.getBodyShapeTransform">
			<summary>
			Returns the transformation matrix of the shape (in the coordinates of the body). This matrix describes position and orientation of the shape. This method is identical to getShapeTransform().
			</summary>  
			<returns>Transformation matrix</returns>
		</member>
		<member name="M:Unigine.Shape.getCenterOfMass">
			<summary>
			Returns local coordinates of the center of mass of the shape.
			</summary>  
			<returns>Coordinates of the center of mass.</returns>
		</member>
		<member name="M:Unigine.Shape.getCollision(Unigine.Vector{Unigine.Ptr{ShapeContact},int,Unigine.VectorAllocator},float)">
			<summary>
			Performs collision check for the shape and puts information on all contacts to the output buffer.					Collisions with the surface can be found only if the following conditions are fulfilled:											The surface is enabled.						Per-surface Collision flag is enabled.						The surface has a material assigned.																The shape must be enabled.
			</summary> 
			<param name="contacts"> Output buffer containing information on all detected physical contacts for the shape (if any). Information on each contact can be handled via the ShapeContact class. </param>
			<param name="ifps"> Inverse FPS value. </param> 
			<returns>1 if collisions are found; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Shape.getCollision(Unigine.Ptr{Unigine.Object},Unigine.Vector{Unigine.Ptr{ShapeContact},int,Unigine.VectorAllocator},float)">
			<summary>
			Performs collision check for the shape and puts information on all contacts and contact object to the output buffer.					Collisions with the surface can be found only if the following conditions are fulfilled:											The surface is enabled.						Per-surface Collision flag is enabled.						The surface has a material assigned.																The shape must be enabled.
			</summary> 
			<param name="object"> Object to be ignored when detecting collisions. This parameter is used when it is necessary to ignore collisions of the shape with the object it belongs to. </param>
			<param name="contacts"> Output buffer containing information on all detected physical contacts for the shape (if any). Information on each contact can be handled via the ShapeContact class. </param>
			<param name="ifps"> Inverse FPS value. </param> 
			<returns>1 if collisions are found; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Shape.setCollisionMask(int)">
			<summary>
			Sets a collision mask for the shape. Two objects collide if they both have matching masks. See also details on additional collision exclusion mask.
			</summary> 
			<param name="mask"> Integer, each bit of which is a mask. </param> 
		</member>
		<member name="M:Unigine.Shape.getCollisionMask">
			<summary>
			Returns the collision mask of the actor. Two objects collide if they both have matching masks.See also details on additional collision exclusion mask.
			</summary>  
			<returns>Integer, each bit of which is a mask.</returns>
		</member>
		<member name="M:Unigine.Shape.setContinuous(int)">
			<summary>
			Enables or disables continuous collision detection for spheres or capsules. Enabled CDD incurs almost no performance penalty. Disabling CCD allows to avoid physics artifacts, if there are any.
			</summary> 
			<param name="continuous"> Positive value to enable CCD; 0 to disable. </param> 
		</member>
		<member name="M:Unigine.Shape.isContinuous">
			<summary>
			Returns a value indicating if continuous collision detection for spheres or capsules is enabled. Enabled CCD incurs almost no performance penalty. Disabling CCD allows to avoid physics artifacts, if there are any.
			</summary>  
			<returns>1 if CCD is enabled; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Shape.setDensity(float)">
			<summary>
			Sets density of a shape. Changing the density influences the mass, that is computed by multiplying shape volume by density.
			</summary> 
			<param name="density"> Density value. If a negative value is provided, 0 will be used instead. </param> 
		</member>
		<member name="M:Unigine.Shape.getDensity">
			<summary>
			Returns the current density of a shape.
			</summary>  
			<returns>Density value.</returns>
		</member>
		<member name="M:Unigine.Shape.setEnabled(int)">
			<summary>
			Enables or disables physical interactions with the shape.
			</summary> 
			<param name="enable"> Positive number to enable physical interactions, 0 to disable them.  </param> 
		</member>
		<member name="M:Unigine.Shape.isEnabled">
			<summary>
			Returns a value indicating if physical interactions with the shape are enabled.
			</summary>  
			<returns>1 if physical interactions with the shape are enabled; otherwise, 0. </returns>
		</member>
		<member name="M:Unigine.Shape.isEnabledSelf">
			<summary>
			Returns a value indicating if the shape is enabled.
			</summary>  
			<returns>1 if the shape is enabled; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Shape.setExclusionMask(int)">
			<summary>
			Sets an bit mask to prevent collisions of the shape with other ones. This mask is independent of the collision mask. For shapes with matching collision masks not to collide, at least one bit of their exclusion mask should match.
			</summary> 
			<param name="mask"> Integer, each bit of which is a mask. </param> 
		</member>
		<member name="M:Unigine.Shape.getExclusionMask">
			<summary>
			Returns the bit mask that prevents collisions of the shape with other ones. This mask is independent of the collision mask. For shape with matching collision masks not to collide, at least one bit of their exclusion mask should match.
			</summary>  
			<returns>Integer, each bit of which is a mask.</returns>
		</member>
		<member name="M:Unigine.Shape.setFriction(float)">
			<summary>
			Sets a friction of the shape surface.
			</summary> 
			<param name="friction"> Friction of the shape surface. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.Shape.getFriction">
			<summary>
			Returns the friction of the shape surface.
			</summary>  
			<returns>Friction of the shape surface.</returns>
		</member>
		<member name="M:Unigine.Shape.setID(int)">
			<summary>
			Sets the unique ID for the shape.
			</summary> 
			<param name="id"> Unique ID. </param> 
		</member>
		<member name="M:Unigine.Shape.getID">
			<summary>
			Returns the unique ID of the shape.
			</summary>  
			<returns>Unique ID.</returns>
		</member>
		<member name="M:Unigine.Shape.getInertia">
			<summary>
			Returns a matrix that represents inertia tensor describing the resistance of the body to rotation in different directions. It is determined by the distribution of mass throughout the body volume.
			</summary>  
			<returns>Inertia tensor.</returns>
		</member>
		<member name="M:Unigine.Shape.getIntersection(Unigine.Math.Vec3,Unigine.Math.Vec3,Unigine.Ptr{PhysicsIntersectionNormal})">
			<summary>
								Performs tracing from the p0 point to the p1 point to find a shape intersected by this line. Intersection is found only for objects with a matching intersection mask.					World space coordinates are used for this function.
			</summary> 
			<param name="p0"> Start point of the line. </param>
			<param name="p1"> End point of the line. </param>
			<param name="intersection"> PhysicsIntersectionNormal class instance containing intersection information </param> 
			<returns>1 if an intersection was detected; otherwise - 0.</returns>
		</member>
		<member name="M:Unigine.Shape.getIntersection(Unigine.Math.Vec3,Unigine.Math.Vec3,Unigine.Ptr{PhysicsIntersection})">
			<summary>
								Performs tracing from the p0 point to the p1 point to find a shape intersected by this line. Intersection is found only for objects with a matching intersection mask.					World space coordinates are used for this function.										Usage Example					The following example shows how you can get the intersection information by using the PhysicsIntersection class. In this example the line is an invisible traced line from the point of the camera (vec3 p0) to the point of the mouse pointer (vec3 p1). It is supposed that you have a dynamic mesh with a body and a shape assigned. The executing sequence is the following:													Define and initialize two points (p0 and p1) by using the Player::getDirectionFromScreen() function.							Create an instance of the PhysicsIntersection class to get the information of the intersection point.							Check, if there is a intersection with a shape and save the result in the integer variable.							In this example, if there is an intersection of mouse direction with a shape, the PhysicsIntersection class instance gets the intersection point. The result is shown in the console.
			</summary> 
			<param name="p0"> Start point of the line. </param>
			<param name="p1"> End point of the line. </param>
			<param name="intersection"> PhysicsIntersection class instance containing intersection information. </param> 
			<returns>1 if an intersection was detected; otherwise - 0.</returns>
		</member>
		<member name="M:Unigine.Shape.getIntersection(Unigine.Math.Vec3,Unigine.Math.Vec3,Unigine.Math.Vec3,Unigine.Math.vec3)">
			<summary>
								Performs tracing from the p0 point to the p1 point to find a shape intersected by this line. Intersection is found only for objects with a matching intersection mask.					World space coordinates are used for this function.
			</summary> 
			<param name="p0"> Start point of the line (in world coordinates). </param>
			<param name="p1"> End point of the line (in world coordinates). </param>
			<param name="ret_point"> Container to which contact point coordinates (if any) shall be put (in world coordinate system). </param>
			<param name="ret_normal"> Container to which contact point normal coordinates (if any) shall be put (in world coordinate system). </param> 
			<returns>1 if an intersection was detected; otherwise - 0.</returns>
		</member>
		<member name="M:Unigine.Shape.setPhysicsIntersectionMask(int)">
			<summary>
			Sets a physics intersection mask for the shape.
			</summary> 
			<param name="mask"> Integer, each bit of which is a mask. </param> 
		</member>
		<member name="M:Unigine.Shape.getPhysicsIntersectionMask">
			<summary>
			Returns a physics intersection mask of the shape.
			</summary>  
			<returns>Integer, each bit of which is a mask.</returns>
		</member>
		<member name="M:Unigine.Shape.setMass(float)">
			<summary>
			Sets a mass of the shape. Changing the mass influences the density, that is computed by dividing the mass by shape volume.					If g (Earth's gravity) equals to 9.8 m/s						2, and 1 unit equals to 1 m, a shape with mass value of						1 weighs 1 kg.
			</summary> 
			<param name="mass"> Mass of the shape. If a negative value is provided, 0 will be used instead.  </param> 
		</member>
		<member name="M:Unigine.Shape.getMass">
			<summary>
			Returns the mass of the shape.					If g (Earth's gravity) equals to 9.8 m/s						2, and 1 unit equals to 1 m, the mass is measured in kilograms.
			</summary>  
			<returns>Mass of the shape.</returns>
		</member>
		<member name="M:Unigine.Shape.setName(char)">
			<summary>
			Sets the name of the shape.
			</summary> 
			<param name="name"> Name of the shape. </param> 
		</member>
		<member name="M:Unigine.Shape.getName">
			<summary>
			Returns the name of the shape.
			</summary>  
			<returns>Name of the shape.</returns>
		</member>
		<member name="M:Unigine.Shape.getNumber">
			<summary>
			Returns the number of shape instances.
			</summary>  
			<returns>Number of shape instances.</returns>
		</member>
		<member name="M:Unigine.Shape.setRestitution(float)">
			<summary>
			Sets a restitution of the shape surface.
			</summary> 
			<param name="restitution"> Restitution of the shape surface. The provided value will be saturated in the range [0; 1].  </param> 
		</member>
		<member name="M:Unigine.Shape.getRestitution">
			<summary>
			Returns the restitution of the shape surface.
			</summary>  
			<returns>Restitution of the shape surface.</returns>
		</member>
		<member name="M:Unigine.Shape.setPosition(Unigine.Math.Vec3)">
			<summary>
			Sets shape position. This method resets shape's velocity to 0.					This method should be called only from the object owning this shape. If the shape is owned by the body, it is highly recommended to use the setShapeTransform() method of the owning body.
			</summary> 
			<param name="position"> New shape's position, in world coordinates. </param> 
		</member>
		<member name="M:Unigine.Shape.getPosition">
			<summary>
			Returns the current shape position of the object, in world coordinates.
			</summary>  
			<returns>Current shape's position, in world coordinates.</returns>
		</member>
		<member name="M:Unigine.Shape.isIdentity">
			<summary>
			Returns a value indicating if the shape has a scale equal to 1 and no rotation.
			</summary>  
			<returns>1 if the shape has a scale equal to 1 and no rotation; otherwise, 0.</returns>
		</member>
		<member name="M:Unigine.Shape.setTransform(Unigine.Math.Mat4)">
			<summary>
			Sets a transformation matrix for the shape of the object (in world coordinates). This matrix describes position and orientation of the shape. This method resets shape's linear velocity to 0.					This method should be called only from the object owning this shape. If the shape is owned by the body, it is highly recommended to use the setShapeTransform() method of the owning body.
			</summary> 
			<param name="transform"> Transformation matrix </param> 
		</member>
		<member name="M:Unigine.Shape.getTransform">
			<summary>
			Returns the transformation matrix of the shape of the object (in world coordinates). This matrix describes position and orientation of the shape.
			</summary>  
			<returns>Transformation matrix</returns>
		</member>
		<member name="M:Unigine.Shape.getType">
			<summary>
			Returns the type of the shape.
			</summary>  
			<returns>One of the SHAPE_* pre-defined variables. </returns>
		</member>
		<member name="M:Unigine.Shape.getTypeName">
			<summary>
			Returns the name of the shape type.
			</summary>  
			<returns>Type name.</returns>
		</member>
		<member name="M:Unigine.Shape.getTypeName(int)">
			<summary>
			Returns the name of a shape type with a given ID.
			</summary> 
			<param name="type"> Shape type ID. One of the SHAPE_* values. </param> 
			<returns>Shape type name.</returns>
		</member>
		<member name="M:Unigine.Shape.setVelocity(Unigine.Math.vec3,float)">
			<summary>
			Sets a new velocity vector for the shape.
			</summary> 
			<param name="velocity"> Velocity vector, each component represents shape's velocity along the corresponding axis, in units per second. </param>
			<param name="ifps"> Inverse FPS value. </param> 
		</member>
		<member name="M:Unigine.Shape.getVelocity">
			<summary>
			Returns the current velocity vector of the shape.
			</summary>  
			<returns>Current celocity vector, each component represents shape's velocity along the corresponding axis, in units per second.</returns>
		</member>
		<member name="M:Unigine.Shape.getVolume">
			<summary>
			Returns the volume of the shape.
			</summary>  
			<returns>Volume of the shape in cubic units.</returns>
		</member>
		<member name="M:Unigine.Shape.clone">
			<summary>
			Clones the shape.
			</summary>  
			<returns>Copy of the shape.</returns>
		</member>
		<member name="M:Unigine.Shape.renderVisualizer(Unigine.Math.vec4)">
			<summary>
			Renders the shape.					You should enable the engine visualizer by the show_visualizer 1 console command.
			</summary> 
			<param name="color"> Color, in which the shape will be rendered. </param> 
		</member>
		<member name="M:Unigine.Shape.saveState(Unigine.Ptr{Unigine.Stream})">
			<summary>
			Saves the state of a given node into a binary stream.											If a node is a parent for other nodes, states of these child nodes need to be saved manually.						To save the state from a buffer, file or a message from a socket, make sure the stream is opened. For buffers and files, you also need to set the proper position for reading.										Example using saveState() and restoreState() methods:
			</summary> 
			<param name="stream"> Stream to save node state data. </param> 
			<returns>true if the node state is saved successfully; otherwise, false.</returns>
		</member>
		<member name="M:Unigine.Shape.restoreState(Unigine.Ptr{Unigine.Stream})">
			<summary>
			Restores the state of a given node from a binary stream.											If a node is a parent for other nodes, states of these child nodes need to be restored manually.						To save the state into a buffer, file or a message from a socket, make sure the stream is opened. If necessary, you can set a position for writing for buffers and files.										Example using saveState() and restoreState() methods:
			</summary> 
			<param name="stream"> Stream with saved node state data. </param> 
			<returns>true if the node state is restored successfully; otherwise, false.</returns>
		</member>
		<member name="M:Unigine.Shape.swap(Unigine.Ptr{Unigine.Shape})">
			<summary>
			Swaps the shapes saving the pointers.
			</summary> 
			<param name="shape"> A shape to swap. </param> 
		</member>
		<member name="M:Unigine.Shape.createShape(int)">
			<summary>
			Creates a new shape of the specified type.
			</summary> 
			<param name="type"> Body type. One of the SHAPE_* values. </param> 
			<returns>New created shape smart pointer.</returns>
		</member>
		<member name="M:Unigine.Shape.createShape(char)">
			<summary>
			Creates a new shape of the specified type.
			</summary> 
			<param name="type_name"> Shape type name. </param> 
			<returns>New created shape smart pointer.</returns>
		</member>
		<member name="F:Unigine.Shape.SHAPE_BOX">
			<summary>
			Box.
		</summary>
		</member>
		<member name="F:Unigine.Shape.SHAPE_CAPSULE">
			<summary>
			Capsule.
		</summary>
		</member>
		<member name="F:Unigine.Shape.SHAPE_CONVEX">
			<summary>
			Convex hull.
		</summary>
		</member>
		<member name="F:Unigine.Shape.SHAPE_CYLINDER">
			<summary>
			Cylinder.
		</summary>
		</member>
		<member name="F:Unigine.Shape.SHAPE_SPHERE">
			<summary>
			Sphere.
		</summary>
		</member>
		<member name="M:Unigine.ShapeBox.#ctor">
			<summary>
			Constructor. Creates a new cylinder with the zero dimensions.
			</summary>  
		</member>
		<member name="M:Unigine.ShapeBox.#ctor(Unigine.Math.vec3)">
			<summary>
			Constructor. Creates a new box with given dimensions.
			</summary> 
			<param name="size"> Dimensions of the box in units. </param> 
		</member>
		<member name="M:Unigine.ShapeBox.#ctor(Unigine.Ptr{Unigine.Body},Unigine.Math.vec3)">
			<summary>
			Constructor. Creates a new box with given dimensions and adds it to a given body.
			</summary> 
			<param name="body"> Body, to which the box will belong. </param>
			<param name="size"> Dimensions of the box in units. </param> 
		</member>
		<member name="M:Unigine.ShapeBox.setSize(Unigine.Math.vec3)">
			<summary>
			Sets box dimensions.
			</summary> 
			<param name="size"> Dimensions of the box in units. </param> 
		</member>
		<member name="M:Unigine.ShapeBox.getSize">
			<summary>
			Returns the current dimensions of the box.
			</summary>  
			<returns>Dimensions of the box in units.</returns>
		</member>
		<member name="M:Unigine.ShapeCapsule.#ctor">
			<summary>
			Constructor. Creates a new capsule with the zero radius and the zero height.
			</summary>  
		</member>
		<member name="M:Unigine.ShapeCapsule.#ctor(float,float)">
			<summary>
			Constructor. Creates a new capsule with given dimensions.
			</summary> 
			<param name="radius"> Radius of the capsule in units. </param>
			<param name="height"> Height of the capsule in units. </param> 
		</member>
		<member name="M:Unigine.ShapeCapsule.#ctor(Unigine.Ptr{Unigine.Body},float,float)">
			<summary>
			Constructor. Creates a new capsule with given dimensions and adds it to a given body.
			</summary> 
			<param name="body"> Body, to which the capsule will belong. </param>
			<param name="radius"> Radius of the capsule in units. </param>
			<param name="height"> Height of the capsule in units. </param> 
		</member>
		<member name="M:Unigine.ShapeCapsule.setHeight(float)">
			<summary>
			Sets a height of the capsule.
			</summary> 
			<param name="height"> Height of the capsule in units. </param> 
		</member>
		<member name="M:Unigine.ShapeCapsule.getHeight">
			<summary>
			Returns the current height of the capsule.
			</summary>  
			<returns>Height of the capsule in units.</returns>
		</member>
		<member name="M:Unigine.ShapeCapsule.setRadius(float)">
			<summary>
			Sets a radius of the capsule.
			</summary> 
			<param name="radius"> Radius of the capsule in units. </param> 
		</member>
		<member name="M:Unigine.ShapeCapsule.getRadius">
			<summary>
			Returns the current radius of the capsule.
			</summary>  
			<returns>Radius of the capsule in units.</returns>
		</member>
		<member name="M:Unigine.ShapeCapsule.getBottomCap">
			<summary>
			Returns the coordinates of the center of the top hemisphere of the capsule.
			</summary>  
			<returns>Coordinates of the center of the capsule's top hemisphere.</returns>
		</member>
		<member name="M:Unigine.ShapeCapsule.getTopCap">
			<summary>
			Returns the coordinates of the center of the bottom hemisphere of the capsule.
			</summary>  
			<returns>Coordinates of the center of the capsule's bottom hemisphere.</returns>
		</member>
		<member name="M:Unigine.ShapeConvex.#ctor">
			<summary>
			Constructor. Creates a new empty convex hull.
			</summary>  
		</member>
		<member name="M:Unigine.ShapeConvex.#ctor(Unigine.Ptr{Unigine.Object},int)">
			<summary>
			Constructor. Creates a convex hull for a given object surface.
			</summary> 
			<param name="object"> Object, which surface will be approximated. </param>
			<param name="surface"> Number of the surface to approximate with the convex hull. </param> 
		</member>
		<member name="M:Unigine.ShapeConvex.#ctor(Unigine.Ptr{Unigine.Body},Unigine.Ptr{Unigine.Object},int)">
			<summary>
			Constructor. Creates a convex hull for a given object surface and adds it to a given body.
			</summary> 
			<param name="body"> Body, to which the convex hull will belong. </param>
			<param name="object"> Object, which surface will be approximated. </param>
			<param name="surface"> Number of the surface to approximate with the convex hull. </param> 
		</member>
		<member name="M:Unigine.ShapeConvex.setObject(Unigine.Ptr{Unigine.Object},int,float)">
			<summary>
			Sets an object surface, for which the convex hull should be created.
			</summary> 
			<param name="object"> Object, which surface will be approximated. </param>
			<param name="surface"> Number of the surface to approximate with the convex hull. If -1 is passed to the function as a number of the surface then the convex hull is created for all the surfaces of the mesh.For a dynamic mesh, the convex hull is not created for all the surfaces. </param>
			<param name="error"> Permissible error, which is used to create the convex hull. This is an optional parameter. </param> 
			<returns>1 if the convex hull is created successfully; otherwise 0.</returns>
		</member>
		<member name="M:Unigine.ShapeCylinder.#ctor">
			<summary>
			Constructor. Creates a new cylinder with the zero radius and the zero height.
			</summary>  
		</member>
		<member name="M:Unigine.ShapeCylinder.#ctor(float,float)">
			<summary>
			Constructor. Creates a new cylinder with given dimensions.
			</summary> 
			<param name="radius"> Radius of the cylinder in units. </param>
			<param name="height"> Height of the cylinder in units. </param> 
		</member>
		<member name="M:Unigine.ShapeCylinder.#ctor(Unigine.Ptr{Unigine.Body},float,float)">
			<summary>
			Constructor. Creates a new cylinder with given dimensions and adds it to a given body.
			</summary> 
			<param name="body"> Body, to which the cylinder will belong. </param>
			<param name="radius"> Radius of the cylinder in units. </param>
			<param name="height"> Height of the cylinder in units. </param> 
		</member>
		<member name="M:Unigine.ShapeCylinder.setHeight(float)">
			<summary>
			Sets a height of the cylinder.
			</summary> 
			<param name="height"> Height of the cylinder in units. </param> 
		</member>
		<member name="M:Unigine.ShapeCylinder.getHeight">
			<summary>
			Returns the current height of the cylinder.
			</summary>  
			<returns>Height of the cylinder in units.</returns>
		</member>
		<member name="M:Unigine.ShapeCylinder.setRadius(float)">
			<summary>
			Sets a radius of the cylinder.
			</summary> 
			<param name="radius"> Radius of the cylinder in units. </param> 
		</member>
		<member name="M:Unigine.ShapeCylinder.getRadius">
			<summary>
			Returns the current radius of the cylinder.
			</summary>  
			<returns>Radius of the cylinder in units.</returns>
		</member>
		<member name="M:Unigine.ShapeSphere.#ctor">
			<summary>
			Constructor. Creates a new sphere with the zero radius.
			</summary>  
		</member>
		<member name="M:Unigine.ShapeSphere.#ctor(float)">
			<summary>
			Constructor. Creates a new sphere with a given radius.
			</summary> 
			<param name="radius"> Radius of the sphere in units. </param> 
		</member>
		<member name="M:Unigine.ShapeSphere.#ctor(Unigine.Ptr{Unigine.Body},float)">
			<summary>
			Constructor. Creates a new sphere with a given radius and adds it to a given body.
			</summary> 
			<param name="body"> Body, to which the shape will belong. </param>
			<param name="radius"> Radius of the sphere in units. </param> 
		</member>
		<member name="M:Unigine.ShapeSphere.setRadius(float)">
			<summary>
			Sets a radius of the sphere.
			</summary> 
			<param name="radius"> Radius of the sphere, in units. </param> 
		</member>
		<member name="M:Unigine.ShapeSphere.getRadius">
			<summary>
			Returns the current radius of the sphere.
			</summary>  
			<returns>Radius of the sphere, in units.</returns>
		</member>
		<member name="M:Unigine.ShapeSphere.setCenter(Unigine.Math.Vec3)">
			<summary>
			Sets the coordinates of the center of the sphere.
			</summary> 
			<param name="center"> Sphere center coordinates. </param> 
		</member>
		<member name="M:Unigine.ShapeSphere.getCenter">
			<summary>
			Returns the current coordinates of the center of the sphere.
			</summary>  
			<returns>Current sphere center coordinates.</returns>
		</member>
	</members>
</doc>