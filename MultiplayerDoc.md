The multiplayer design for this project to be blunt is going to be very unconventional since the main goal of the project is to have determinism and lockstep features so that clientscan simulate locally and do things like prediction.  Yet we are posed with a challenge of keeping latency issues minimal and shouldn't require the players simulate a server's entire input command buffer or state in general whenever joining to catch up, or when traveling, hence a mixed approach must be taken.  I recommend taking a look at the video lecture on overwatch's gameplay and netcode since that's mostly going to be the backbone for this project.  Yet this design in the time of writing this doc doesn't seem to be used for any large scale projects.  What essentially must happen is that players must send only input state to the server, the server sends other relevent input back to the players with a timestamp.  The players must able to unwind as much as reasonably possible to do corrections locally and attempt to catch back up, meaning their processing loads must be generally lower than the server itself.  So a balancing must be struck on what clients can do, simulate locally, and generally know about, it must be designed gameplay conscious.  And for this reason we must design a very specialized approach to solve all of these problems in hopefully a clean enough way.  Essentially we are going to be using lockstep and replication hand in hand a lot.

Since our backend is using ECS rewinding and general data replication should be not too painful a task with enough conscious effort.  There'll have to be a lot of trail and error and a plentiful use of command buffers and other backend utilities to make the process smooth.  So this doc is going to generally note all abstractions created to assist with this problem, and note any important quirks along the way.

## Physics Engine
The physics engine is required to provied rewind utility, internally this could be achieved a lot of ways, but for usage all you should have to do is call a helper method such as "unwind(ticksPassed)", and let it reset it's state accordingly before simulating again as need be.  So now for the proposed internal design.
Since the physics engine is for now intentionally designed to be very simple to avoid pointless overhead, we could try taking further advantage of the situation.  For now it doesn't use friction nor weights nor has any kind of bouncing mechanics.  The ideal approach may involve saving a command buffer of past calls to setVelocity and setPosition ect, as well as saving all position modifications simulated per dynamic body per tick.  10K moving bodies saving positions every tick is only about 120KB per tick.  Which is about 432MB of data saved over a min.  Good news is the server won't require any unwinding capabilities thus all of these extra steps won't need be taken on it.  If in the future the physics engine gets more complicated, we will probably be forced t store along side positional data, things like velocity and whatever else gets added such as friction/weight ect.  Meaning from the outset the game should be designed such that each player doesn't simulate more than 1/10th what the server could physics side.